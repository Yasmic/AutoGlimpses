[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "This is about me"
  },
  {
    "objectID": "Autosar/index.html",
    "href": "Autosar/index.html",
    "title": "Autosar",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nDiagnostic communication manager\n\n\n\n\n\n\n\nBSW\n\n\n\n\nDCM\n\n\n\n\n\n\nAug 26, 2022\n\n\nYasmi\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "C_Plus_Plus/index.html",
    "href": "C_Plus_Plus/index.html",
    "title": "C Plus Plus",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nGlimpse of C++\n\n\n\n\n\n\n\nAdvanced C++ study\n\n\n\n\nBasics to Advanced C++ study\n\n\n\n\n\n\nAug 6, 2023\n\n\nYas Mi\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Notes/index.html",
    "href": "Notes/index.html",
    "title": "Notes",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nNotes\n\n\n\n\n\n\n\nNotes\n\n\n\n\nNotes\n\n\n\n\n\n\nAug 26, 2022\n\n\nYasmi\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Auto Glimpses",
    "section": "",
    "text": "Home page Author: Yasmi"
  },
  {
    "objectID": "C_Plus_Plus/basics_of_cpp.html",
    "href": "C_Plus_Plus/basics_of_cpp.html",
    "title": "Glimpse of C++",
    "section": "",
    "text": "A class template is prescription for creating a class in which one or more types or values are prameterized .\nLet us see how to define and declare class templates  template &lt;class T&gt;\n\ntemplate key word always begins both the definition and a declaration of a class template .\ntemplate key word is followed by list of user defined data type separated by comma\nand surrounded by the less than (&lt;) and greater than (&gt;) tokens.\nIn place of class key word typename could also be used as shown below template &lt;typename T&gt;\n\nBelow is the simple program to understand the template class\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}\ntemplate class can also have nontype parameter ,mostly it will be constant template &lt;class T, int size&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}"
  },
  {
    "objectID": "C_Plus_Plus/basics_of_cpp.html#class-templates",
    "href": "C_Plus_Plus/basics_of_cpp.html#class-templates",
    "title": "Glimpse of C++",
    "section": "",
    "text": "A class template is prescription for creating a class in which one or more types or values are prameterized .\nLet us see how to define and declare class templates  template &lt;class T&gt;\n\ntemplate key word always begins both the definition and a declaration of a class template .\ntemplate key word is followed by list of user defined data type separated by comma\nand surrounded by the less than (&lt;) and greater than (&gt;) tokens.\nIn place of class key word typename could also be used as shown below template &lt;typename T&gt;\n\nBelow is the simple program to understand the template class\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}\ntemplate class can also have nontype parameter ,mostly it will be constant template &lt;class T, int size&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}"
  },
  {
    "objectID": "C_Plus_Plus/basics_of_cpp.html#lambda-function",
    "href": "C_Plus_Plus/basics_of_cpp.html#lambda-function",
    "title": "Glimpse of C++",
    "section": "2 Lambda function",
    "text": "2 Lambda function\nFormat :\n[] () mutable throw() -&gt; int \n{\n    //lambda body\n} \n[] Lambda introducer also called capture clause  () Lambda declarator also called parameter list  mutable also known as mutable specification  exception specification return type lambda body\nCapture clause \n[] -lambda does not access enclosing scope [=] -captures everything by value  [&]-capture everything by reference [x,&y]-capture x by value and y by reference [&,z]-capture everything by reference,but z by value \nLambda function example \n int x=9;\n  auto add_one = [x] (const int value) \n    {\n        x=2;//Error \n\n         //x is captured by copy so the x value cannot be modified inside the lambda function \n        //in order to change/update the value of x add \"mutable keyword after parameter list \"\n        //or capture the x value by reference in the capture clause\n        return value + 1+x;\n    };\n  \n  //Method 1\n    auto add_one = [x] (const int value) mutable\n    {\n        x=2;\n        return value + 1+x;\n    };\n    cout&lt;&lt;(add_one(2))&lt;&lt;endl; //12\n\n     //Method 2\n    auto add_one = [&x] (const int value) \n    {\n        x=2;\n        return value + 1+x;\n    };\n    cout&lt;&lt;(add_one(2))&lt;&lt;endl;//12"
  },
  {
    "objectID": "C_Plus_Plus/basics_of_cpp.html#multi-threading",
    "href": "C_Plus_Plus/basics_of_cpp.html#multi-threading",
    "title": "Glimpse of C++",
    "section": "3 MULTI THREADING",
    "text": "3 MULTI THREADING\n\nPurpose of Mutex : A mutex is used to coordinate mutually exclusive access to resources by multiple threads of execution. The mutex class is used to protect shared data from corruption due to simultaneous access by multiple threads.\nPurpose of producer consumer idiom : o facilitate threads that produce data and threads that consume data using a single common and coordinated container In the producer-consumer idiom one thread produces data and another consumes data, using one container to hold the data.\nWhat is the difference between sleep_for and sleep_until? sleep_for will sleep for a specified interval; sleep_until will sleep until a specified point in time. Both functions are in the this_thread namespace and both use objects from the chrono library for their arguments.\nHow does async return values from a thread? async returns values in a future object async uses the promise and future paradigm to return values to the caller.\nthread::join() method use case? The join() method blocks execution of the caller until the thread completes.\nWhat types qualify for use with std::atomic? std::atomic requires a trivial type. All primitive types are trivial, including bool, int, float, and double. std::atomic works with any trivial type. Trivial types include primitives such as bool, int, float, and double, as well as any class that uses the default constructor, copy constructor, copy assignment, and destructor.\n\n\n3.1 Thread\nThread is useful for parallelism\nThread shall be created by below methods\n\nFunction pointer\nLambda function\nFunctor\nNon static member function\nStatic member function\n\nJoin helps to include the thread to main thread here the main thread is main function , if join is not present the main thread continue to execute before waiting for the t1 thread to finish .\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid countFunction()\n{\n    for(int i=0;i&lt;10;i++)\n    {\n        counter++;\n        cout&lt;&lt;\"count function\"&lt;&lt;endl;\n    }\n}\n\n\nint main()\n{\ncout&lt;&lt;\"Main thread called\"&lt;&lt;endl;\n//Thread creation using function pointer\nthread t1(countFunction);\nt1.join();\ncout&lt;&lt;\"Main thread continued\"&lt;&lt;endl;\n}\nThread creation\nclass fClass\n{\n    public:\n    void operator()(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n\n    void printf(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n\n\n    static void printSt(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n};\n\nvoid print(int x)\n{\ncout&lt;&lt;x&lt;&lt;endl;\n}\nint main()\n{\n    //Thread creation using function pointer\n    thread t1(print,10);\n    t1.join;\n   //Thread creation using lambda\n   thread t3(([](int x){cout&lt;&lt;x&lt;&lt;endl;}),10);\n    t3.join();\n    //Thread creation using functor \n    thread t3(fClass(),10);\n    t3.join();\n    //Thread creation using non static member function \n    fClass obj;\n    thread t4(&fClass::printf,&obj,10);\n    t4.join();\n    //Thread creation using static member\n    thread t5(fClass::printSt,10);\n}\n\n\n3.2 Join\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.join();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n}\nResult : main  thread print - (waiting for 5sec) it prints after join  main continued \nWhen the thread created it starts running the thread and the control comes back to the main thread(Parent thread) to execute if join is mentioned it will not execute further it waits for the tread to finish its job\nDouble time join is not allowed, so always check if the thread is joinable using \nif(t1.joinable )\n{\n    t1.join\n}\n\n\n3.3 Detach\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n     cout&lt;&lt;\"thread done\"&lt;&lt;endl;\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.detach();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n    return 0;\n}\nResult : main main continued \nThe result keep changing if we get this result which means the thread function print taking more time (probably due to the wait time given )to run than the main thread printing and returning\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     cout&lt;&lt;\"thread done\"&lt;&lt;endl;\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.detach();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n    return 0;\n}\nif the thread gets finished by 3seconds of wait period of main thread (PArent) Result could be  Main Main continued  Thread print  Thread done\nBut if the main function is returning before completing the thread then that thread will be suspended the result will be just main and main continued .\nAnd double time the detach is also not possible so always check if the thread is joinable if the thread is joinable then only the detaching also possible\n\n\n3.4 Mutex\nIf we create multiple threads in the program we donno which executes in what order\nMutual exclusion\nRace condition its a situation where two or more threads access to the same data and try to modify that data at the same time\nif there is any race condition we have to protect the data so that there wont be any unpredicted result\nMutex helps to avoid the race condition using the lock commands\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nint counterdata=0;\nvoid countData(int x)\n{\n    counterdata++;\n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \ncountdata will be updated by both thread t1 and t2 that forms the race condition . In order to avoid that we have to use mutex .\nThe critical section or critical reqion is where the data is updated at the same time by the threads .. To avoid that we have to use lock and unlock\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nusing namespace std;\nint counterdata=0;\nmutex mx;\nvoid countData(int x)\n{\n    mx.lock();\n    counterdata++;\n    mx.unlock();\n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \nHere which ever thred reaches first to the cpu then that thread lets say t1 will acquire the lock before t2.\ntry_lock If try_lock is used it returns true for the sucesfull lock aquisitions else return false.\nIf try_lock is not able to lock the mutex then it doesnt get blocked .\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nusing namespace std;\nint counterdata=0;\nmutex mx;\nvoid countData()\n{\n    if(mx.try_lock())\n    {\n        counterdata++;\n        mx.unlock();\n    }\n \n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \nHere the result is so random , since the thread wont wait for the locking to complete , so the actual result might also change\nIf i have a single core then how the thread parallally executes in c++ ?\n\nOn a single-core machine, threads do not execute truly in parallel. Instead, what gives the illusion of parallelism is something called “time-slicing” or “preemptive multitasking.”\nContext Switching: The operating system rapidly switches between running threads. It gives each thread a little “slice” of time to execute. When a thread’s time slice is up, its current state (context) is saved, and the CPU starts executing another thread.\nConcurrency vs. Parallelism: It’s important to differentiate between concurrency and parallelism. Concurrency is about dealing with a lot of things at once (which can be achieved through mechanisms like context switching), while parallelism is about doing a lot of things at once (which requires multiple cores or processors).\nBenefits on Single Core: Even on a single-core machine, using threads can be beneficial. For instance, if one thread is waiting for I/O (like reading a file or waiting for a network response), another thread can use the CPU. This way, the CPU isn’t idly waiting and can be used more efficiently.\nOverhead: Using multiple threads introduces overhead because of the need for context switches, synchronization mechanisms, etc. On a single-core machine, overusing threads (especially for tasks that are purely computational) can even lead to worse performance due to this overhead.\nLanguages & Libraries: In C++ specifically, the standard  library gives you tools to create and manage threads. But the behavior in terms of how these threads are scheduled and executed depends on the operating system’s scheduler.\nCooperative Multitasking: This is another form of multitasking where tasks yield control periodically or when idle to enable multiple tasks to run in a single-threaded environment. This approach depends more on the tasks being well-behaved and giving up control often.\n\n\n\n3.5 try_lock()\nIt tries to lock all the loackable objets passed one by one in given order\nstd::try_lock(lm1,lm2....lmn)\nIf locked sucesfully function returns -1 otherwise it will return mutex index number which was not able to lock . if any one of the mutex is unable to lock ,it will release all the mutex which were previously locked . if try_lockresults in exception ,unlock is called for any locked object before rethrowing \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1,m2;\nint global_data=0;\n\nvoid function_Add(int x,mutex &m,int v)\n{\n    for(int i=0;i&lt;4;i++)\n    {\n        m.lock();\n        x=x+v;\n        global_data=x;\n        m.unlock();\n\n    }\n}\n\nvoid function_trylock_print()\n{\n    int lockResult=try_lock(m1,m2);\n    //Checks if try_lock is sucesful\n    if(lockResult==-1)\n    {\n        cout&lt;&lt;global_data&lt;&lt;endl;\n    }\n    m1.unlock();\n    m2.unlock();\n}\n\nint main()\n{\n    thread th1(function_Add,20,ref(m1),1);\n    thread th2(function_Add,20,ref(m2),2);\n    thread th3(function_trylock_print);\n    th1.join();\n    th2.join();\n    th3.join();\n    return 0;\n}\n\ntry_lock_for() -Tries the lock for specified duration - if waits for the amount of time mentioned to get the lock . The threads tries to get the lock for time mentioned in try_lock_for . Its used for time critical operations\ntry_lock_until - Waits until specified timeout time has been reached or the lock is aquired which ever comes first .if lock is quired return true else false\n\n\n\n3.6 Recursive mutex\n\nSame thread can lock one mutex multiple times using recursive_mutex\nThe lock and unlock should match in recursive_mutex\nNo of times locking is system specific , if we reach that many times it will return system_error if we call lock() , if we call try_lock then return false\n\nrecursive_mutex\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nrecursive_mutex m;\n\nint function_recursion(int x)\n{\n    if(x&lt;=0)\n    {\n        return 1;\n    }\n    m.lock();\n    cout&lt;&lt;\"data=\"&lt;&lt;x&lt;&lt;endl;\n    function_recursion(--x);\n    m.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_recursion,3);\n    thread th4(function_recursion,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\n\n3.7 Lock guard in C++\nlock_guard&lt;mutex&gt;lock(m)where m is mutex - with lock_guard you dont have to unlock unlike the conventional way where we use unlockmethod - when the object is created it will lock the mutex ,the unlock happens in the destructor of the lock_guard ,it unlocks automatically when it goes out of scope since the object is created in stack.\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m;\nint counter=0;\nvoid function_lock_guard(int x)\n{\n  lock_guard&lt;mutex&gt;lock(m);\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n}\n\nint main()\n{\n\n    thread th3(function_lock_guard,3);\n    thread th4(function_lock_guard,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\nResult is : 1,2,3,4,5,6\n\n\n\n3.8 Unique Lock\nunique_lock&lt;mutex&gt;lock(m)where m is mutex it works just like the lock_guard\n\nLocking strategies \ndefer_lock -It does not lock the mutex ,locking should be done at later point\ntry_to_lock it aquires the mutex but without blocking \nadopt_lock it assumes the calling thread aquired the mutex\nit allows\n\ntime based locking such as  try_lock_for, try_lock_until\nRecurstive locking allowed \nMove the lock possible \nCondition_varaible -Notification to the threads \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m;\nint counter=0;\nvoid function_unique_lock(int x)\n{\n  unique_lock&lt;mutex&gt;lock(m,defer_lock);//owning the mutex but it doesnt lock \n  lock.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n}\n\nint main()\n{\n\n    thread th3(function_unique_lock,3);\n    thread th4(function_unique_lock,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\n\n3.9 Condition variable\nPurpose  - Notify other threads notify_one() to single thread or notify_all() to all the thread - Waiting for some condition\nTo synchronise the thread all the thread should have common condition_variable\nIt uses unique_lock\nThe current thread waits and release the lock so that the other thread can execute\nIf we want to start particular thread to start first its best to use the condition_varaible since it wait on some condition variable\nfor this we can use wait ,wait_for ,wait_untilbased on our need\n\nThread Synchronisation example using condition_variable\n\nIn order to ensure thread synchronisation need to use condition_varaible In that wait and notify_allcommands wait takes argument lock and false to go for waiting and control will be given to next thread  once the notify_allcommand is executed the control gives back to the previous thread if the argument is true then the current thread wont wait and continue its execution \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nstatic int counterdata=1;\n\nmutex mx;\ncondition_variable cv;\n\nvoid PrintEvenData(int n)\n{\n         \n    for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==0;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n}\n\nvoid PrintOddData(int n)\n{\n         \n     for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==1;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n   \n}\nint main()\n{\n    thread th1(PrintEvenData,20);\n    thread th2(PrintOddData,20);\n     th1.join();\n    th2.join();\n    return 0;\n}\n\n3.9.1 Thread Synchronisation example using condition_variable\nIn order to ensure thread synchronisation need to use condition_varaible In that wait and notify_allcommands wait takes argument lock and false to go for waiting and control will be given to next thread  once the notify_allcommand is executed the control gives back to the previous thread if the argument is true then the current thread wont wait and continue its execution  Best use is producer consumer problem\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nstatic int counterdata=1;\n\nmutex mx;\ncondition_variable cv;\n\nvoid PrintEvenData(int n)\n{\n         \n    for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==0;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();//this is not needed since the unique_lock unlocks by itself in its destructor\n        cv.notify_all();//if more than one thread this could be used \n    }\n}\n\nvoid PrintOddData(int n)\n{\n         \n     for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==1;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n   \n}\nint main()\n{\n    thread th1(PrintEvenData,20);\n    thread th2(PrintOddData,20);\n     th1.join();\n    th2.join();\n    return 0;\n}\n\n\n\n3.10 Dead Lock\nIn multiple resource sharing scenarios if the threads are holding the resource and not able to release which is deadlock .\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\nint counter=0;\nvoid function_one(int x)\n{\n  m1.lock();\n  this_thread::sleep_for(chrono::seconds(3));\n  m2.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n  cout&lt;&lt;\"critical section two\"&lt;&lt;endl;\n  m1.unlock();\n  m2.unlock();\n}\n\nvoid function_two(int x)\n{\n  m2.lock();\n   this_thread::sleep_for(chrono::seconds(3));\n  m1.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n  cout&lt;&lt;\"critical section one\"&lt;&lt;endl;\n  m1.unlock();\n  m2.unlock();\n}\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\nIn function_one() locks m1 and goes for sleep by the time function_two locks m2\nIn function_two() locks m2 and goes for sleep\nThe function_one() waits for unlocking of m2 to execute the code in the critical section\nThe function_two() also waiting for unlocking of m1 to execute the code in the critical section\nThis situation is nothing but deadlock\n\nTo avoid this we shouldnt change the order of mutex locking (m1 and m2 in both the function)\n\n\n3.11 Thread/Process synchronisation\nCritical section is one or collection of program statement which should be executed by only one thread or process at a time. Thread/process synchronize to access critical section if the data is common between the threads it is critical section , and if the data is used only for reading then its not considered as critical section but if there is a write operation between threads to update the same data then it becomes critical section\n\nBelow is the example of race condition we donno exactly the value of counter ,it will be impossible to get 8 it might be 3 or 5\n\n\n#include&lt;thread&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint counter=0;\nvoid function_one(int x)\n{\n counter+=x;\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_one,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\n\nHow to avoid this : using mutex\n\nmutex m1;\n\nint counter=0;\nvoid function_one(int x)\n{\n    m1.lock();\n    counter+=x;\n    m1.unlock();\n}\n\n\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_one,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\nHere lets say both the thread reached to lock at the same time , and one of them gets the access randomly to lock and access critical section lets say th1 got access then other thread is waiting and after writing counter it will release using unlock now the th2 can access by locking and continue to write .But here one thread is writing critical section at one time , only one thread at a time can execute if one of the thread dont unlock the other thread keeps waiting and goes to deadlock condition this is the reason the thread synchronisation is very important\n\nBut how do we ensure thread synchronisation without deadlock?\n\n\n3.11.1 std::lock(m1,m2,m3….mn)\n\nIt allows to lock multiple mutex same time\nIt will not let to happen deadlock\nIt can use lock(), try_lock() or unlock()\nif one of them is not locked it will unlock all and tries another time by re arranging the sequence order of mutex locking . previously ,3 couldnt lock internally from next time when it tries it will try to lock first m3 then tries remaining and every time it ensures no deadlock scenario occurs.\n\nDeadlock example\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\n\nint counter=0;\nvoid function_one(int x)\n{\n    m2.lock();\n    this_thread::sleep_for(chrono::seconds(3));\n    m1.lock();\n    counter+=x;\n    m2.unlock();\n    m1.unlock();\n}\n\nvoid function_two(int x)\n{\n    m1.lock();\n    this_thread::sleep_for(chrono::seconds(3));\n    m2.lock();\n    counter+=x;\n    m1.unlock();\n    m2.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\n\nHow to avoid them\n\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\n\nint counter=0;\nvoid function_one(int x)\n{\n    lock(m1,m2);\n    this_thread::sleep_for(chrono::seconds(3));\n    counter+=x;\n    m1.unlock();\n    m2.unlock();\n\n}\n\nvoid function_two(int x)\n{\n   lock(m2,m1);\n    this_thread::sleep_for(chrono::seconds(3));\n    counter+=x;\n    m2.unlock();\n    m1.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\nExample\nNo deadlock  ex:1 - lock(m1,m2) - for thread 1 - lock(m1,m2)- for thread 2\nex:2 Thread1 - lock(m1,m2)-Th1 is locked m1\nThread 2 - lock(m2,m1)- Th2 is locked m2 it releases lock and tries after some time by the time thread 1 is released so the Th2 would be able to finish even it changes the order of locking and then release for Th1 vice versa\nDeadlock \n\n\n\n3.12 Promise and Future\n\nstd::promise Used to set values or exceptions\nstd::future It Wait for the promise It enquire promise if the values are available It gets the values from the promise"
  }
]