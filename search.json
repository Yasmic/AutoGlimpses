[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "This is about me"
  },
  {
    "objectID": "Autosar/index.html",
    "href": "Autosar/index.html",
    "title": "Autosar",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nDiagnostic communication manager\n\n\n\nDiagnostics\n\n\n\nDCM\n\n\n\n\n\nSep 16, 2023\n\n\nYasmi\n\n\n\n\n\n\n\n\n\n\n\n\nDiagnostic event manager\n\n\n\nDiagnostics\n\n\n\nDEM\n\n\n\n\n\nSep 16, 2023\n\n\nYasmi\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "{{< fa house >}} Home",
      "Autosar"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Smart-Pointers/smartPointers_basics.html",
    "href": "C_Plus_Plus/Smart-Pointers/smartPointers_basics.html",
    "title": "smart pointers",
    "section": "",
    "text": "#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;utility&gt;\n\nclass Example\n{\npublic:\n    std::string name;\n\n    Example(const std::string &n) : name(n)\n    {\n    }\n\n    void display() const\n    {\n        std::cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;typename T&gt;\nclass uniquePointer\n{\n    T *ptr;\n\npublic: \n    explicit uniquePointer(T *ptr = nullptr) : ptr(ptr)\n    {\n    }\n\n    uniquePointer(const uniquePointer &p) = delete;\n    uniquePointer &operator =(const uniquePointer &p) = delete;\n\n    T *get() const\n    {\n        return ptr;\n    }\n\n    uniquePointer(uniquePointer &&p) noexcept\n    {\n        ptr = p.ptr;\n        p.ptr = nullptr;\n    }\n\n    uniquePointer &operator=(uniquePointer &&p) noexcept\n    {\n        if (this != p) {\n            delete ptr;\n            ptr = p.ptr;\n            p.ptr = nullptr;\n        }     \n        return *this;\n    }\n\n    T *operator -&gt;()\n    {\n        return ptr;\n    }\n\n    T &operator *()\n    {\n        return *ptr;\n    }\n\n    ~uniquePointer()\n    {\n        delete ptr;\n    }\n\n};\n\n\nint main()\n{\n    uniquePointer&lt;int&gt; obj(new int(4));\n    auto ptr = obj.get();\n    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;\n\n    uniquePointer&lt;Example&gt; obj1(new Example(\"Tom\"));\n    obj1-&gt;display();\n\n    // Demonstrate move semantics\n    uniquePointer&lt;Example&gt; obj3 = std::move(obj1);\n    obj3-&gt;display();\n\n    if (obj1.get() == nullptr)\n    {\n        std::cout &lt;&lt; \"obj1 has released ownership.\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\nOutput :\n4\nName: Tom\nName: Tom\nobj1 has released ownership.",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Smart Pointers",
      "smart pointers"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Smart-Pointers/smartPointers_basics.html#unique-pointer",
    "href": "C_Plus_Plus/Smart-Pointers/smartPointers_basics.html#unique-pointer",
    "title": "smart pointers",
    "section": "",
    "text": "#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;utility&gt;\n\nclass Example\n{\npublic:\n    std::string name;\n\n    Example(const std::string &n) : name(n)\n    {\n    }\n\n    void display() const\n    {\n        std::cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;typename T&gt;\nclass uniquePointer\n{\n    T *ptr;\n\npublic: \n    explicit uniquePointer(T *ptr = nullptr) : ptr(ptr)\n    {\n    }\n\n    uniquePointer(const uniquePointer &p) = delete;\n    uniquePointer &operator =(const uniquePointer &p) = delete;\n\n    T *get() const\n    {\n        return ptr;\n    }\n\n    uniquePointer(uniquePointer &&p) noexcept\n    {\n        ptr = p.ptr;\n        p.ptr = nullptr;\n    }\n\n    uniquePointer &operator=(uniquePointer &&p) noexcept\n    {\n        if (this != p) {\n            delete ptr;\n            ptr = p.ptr;\n            p.ptr = nullptr;\n        }     \n        return *this;\n    }\n\n    T *operator -&gt;()\n    {\n        return ptr;\n    }\n\n    T &operator *()\n    {\n        return *ptr;\n    }\n\n    ~uniquePointer()\n    {\n        delete ptr;\n    }\n\n};\n\n\nint main()\n{\n    uniquePointer&lt;int&gt; obj(new int(4));\n    auto ptr = obj.get();\n    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;\n\n    uniquePointer&lt;Example&gt; obj1(new Example(\"Tom\"));\n    obj1-&gt;display();\n\n    // Demonstrate move semantics\n    uniquePointer&lt;Example&gt; obj3 = std::move(obj1);\n    obj3-&gt;display();\n\n    if (obj1.get() == nullptr)\n    {\n        std::cout &lt;&lt; \"obj1 has released ownership.\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\nOutput :\n4\nName: Tom\nName: Tom\nobj1 has released ownership.",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Smart Pointers",
      "smart pointers"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Advanced/advanced_cpp.html",
    "href": "C_Plus_Plus/Advanced/advanced_cpp.html",
    "title": "Advanced C++ study",
    "section": "",
    "text": "A class template is prescription for creating a class in which one or more types or values are prameterized .\nLet us see how to define and declare class templates  template &lt;class T&gt;\n\ntemplate key word always begins both the definition and a declaration of a class template .\ntemplate key word is followed by list of user defined data type separated by comma\nand surrounded by the less than (&lt;) and greater than (&gt;) tokens.\nIn place of class key word typename could also be used as shown below template &lt;typename T&gt;\n\nBelow is the simple program to understand the template class\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}\ntemplate class can also have nontype parameter ,mostly it will be constant template &lt;class T, int size&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Advanced",
      "Advanced C++ study"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Advanced/advanced_cpp.html#class-templates",
    "href": "C_Plus_Plus/Advanced/advanced_cpp.html#class-templates",
    "title": "Advanced C++ study",
    "section": "",
    "text": "A class template is prescription for creating a class in which one or more types or values are prameterized .\nLet us see how to define and declare class templates  template &lt;class T&gt;\n\ntemplate key word always begins both the definition and a declaration of a class template .\ntemplate key word is followed by list of user defined data type separated by comma\nand surrounded by the less than (&lt;) and greater than (&gt;) tokens.\nIn place of class key word typename could also be used as shown below template &lt;typename T&gt;\n\nBelow is the simple program to understand the template class\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}\ntemplate class can also have nontype parameter ,mostly it will be constant template &lt;class T, int size&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class ValueType&gt;\nclass tempClass\n{\npublic:\ntempClass(){}\nvoid updateDataType(ValueType data);\n\n};\n\ntemplate &lt;class ValueType&gt;\nvoid tempClass &lt; ValueType&gt;::updateDataType(ValueType data)\n{\n cout &lt;&lt;\"data=\"&lt;&lt;data&lt;&lt;endl;\n}\nint main()\n{\n    tempClass&lt;int&gt; tempObject;\n    tempObject.updateDataType(5);\n\n    tempClass&lt;char&gt; tempObjectchar;\n    char value='a';\n    tempObject.updateDataType(value);\n    return 0;\n}",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Advanced",
      "Advanced C++ study"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Advanced/advanced_cpp.html#lambda-function",
    "href": "C_Plus_Plus/Advanced/advanced_cpp.html#lambda-function",
    "title": "Advanced C++ study",
    "section": "2 Lambda function",
    "text": "2 Lambda function\nFormat :\n[] () mutable throw() -&gt; int \n{\n    //lambda body\n} \n[] Lambda introducer also called capture clause  () Lambda declarator also called parameter list  mutable also known as mutable specification  exception specification return type lambda body\nCapture clause \n[] -lambda does not access enclosing scope [=] -captures everything by value  [&]-capture everything by reference [x,&y]-capture x by value and y by reference [&,z]-capture everything by reference,but z by value \nLambda function example \n int x=9;\n  auto add_one = [x] (const int value) \n    {\n        x=2;//Error \n\n         //x is captured by copy so the x value cannot be modified inside the lambda function \n        //in order to change/update the value of x add \"mutable keyword after parameter list \"\n        //or capture the x value by reference in the capture clause\n        return value + 1+x;\n    };\n  \n  //Method 1\n    auto add_one = [x] (const int value) mutable\n    {\n        x=2;\n        return value + 1+x;\n    };\n    cout&lt;&lt;(add_one(2))&lt;&lt;endl; //12\n\n     //Method 2\n    auto add_one = [&x] (const int value) \n    {\n        x=2;\n        return value + 1+x;\n    };\n    cout&lt;&lt;(add_one(2))&lt;&lt;endl;//12",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Advanced",
      "Advanced C++ study"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/linkedlist_basics.html",
    "href": "C_Plus_Plus/Linked-list/linkedlist_basics.html",
    "title": "Linkedlist Basics",
    "section": "",
    "text": "// Created by Yasmi on 13/11/24.\n\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtHead(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            auto *newNode = new Node(data);\n            newNode-&gt;next = head;\n            head = newNode;\n\n        }\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n\n            temp-&gt;next = new Node(data);\n        }\n    }\n\n    void insertAtanyPosition(int data, int position)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            int currentPos = 1;\n            Node *temp = head;\n            Node *previous = nullptr;\n            while (temp != nullptr && currentPos &lt; position)\n            {\n\n                currentPos++;\n                previous = temp;\n                temp = temp-&gt;next;\n            }\n\n            if (currentPos == position)\n            {\n                Node *newNode = new Node(data);\n                newNode-&gt;next = temp;\n                previous-&gt;next = newNode;\n            }\n        }\n    }\n\n    void deleteFromPosition(int position)\n    {\n        int currentPos = 1;\n        Node *temp = head;\n        Node *previous = nullptr;\n        while (temp != nullptr && currentPos &lt; position)\n        {\n            currentPos++;\n            previous = temp;\n            temp = temp-&gt;next;\n        }\n\n        if (currentPos == position)\n        {\n            previous-&gt;next = temp-&gt;next;\n        }\n    }\n\n    void display() const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n\n    }\n\n    ~singleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp;\n                temp = nextNode;\n            }\n\n        }\n    }\n};\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtHead(12);\n    obj.insertAtTail(24);\n    obj.insertAtTail(36);\n    obj.insertAtTail(48);\n    obj.insertAtTail(94);\n    std::cout &lt;&lt; \"list before modification\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; \"list after modification\" &lt;&lt; std::endl;\n    obj.insertAtanyPosition(72, 5);\n    obj.display();\n    std::cout &lt;&lt; \"list after deleting\" &lt;&lt; std::endl;\n    obj.deleteFromPosition(4);\n    obj.display();\n    return 0;\n}\nOutput :\nlist before modification\n12 24 36 48 94 \nlist after modification\n12 24 36 48 72 94 \nlist after deleting\n12 24 36 72 94",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "Linkedlist Basics"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/linkedlist_basics.html#single-linkedlist",
    "href": "C_Plus_Plus/Linked-list/linkedlist_basics.html#single-linkedlist",
    "title": "Linkedlist Basics",
    "section": "",
    "text": "// Created by Yasmi on 13/11/24.\n\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtHead(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            auto *newNode = new Node(data);\n            newNode-&gt;next = head;\n            head = newNode;\n\n        }\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n\n            temp-&gt;next = new Node(data);\n        }\n    }\n\n    void insertAtanyPosition(int data, int position)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            int currentPos = 1;\n            Node *temp = head;\n            Node *previous = nullptr;\n            while (temp != nullptr && currentPos &lt; position)\n            {\n\n                currentPos++;\n                previous = temp;\n                temp = temp-&gt;next;\n            }\n\n            if (currentPos == position)\n            {\n                Node *newNode = new Node(data);\n                newNode-&gt;next = temp;\n                previous-&gt;next = newNode;\n            }\n        }\n    }\n\n    void deleteFromPosition(int position)\n    {\n        int currentPos = 1;\n        Node *temp = head;\n        Node *previous = nullptr;\n        while (temp != nullptr && currentPos &lt; position)\n        {\n            currentPos++;\n            previous = temp;\n            temp = temp-&gt;next;\n        }\n\n        if (currentPos == position)\n        {\n            previous-&gt;next = temp-&gt;next;\n        }\n    }\n\n    void display() const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n\n    }\n\n    ~singleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp;\n                temp = nextNode;\n            }\n\n        }\n    }\n};\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtHead(12);\n    obj.insertAtTail(24);\n    obj.insertAtTail(36);\n    obj.insertAtTail(48);\n    obj.insertAtTail(94);\n    std::cout &lt;&lt; \"list before modification\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; \"list after modification\" &lt;&lt; std::endl;\n    obj.insertAtanyPosition(72, 5);\n    obj.display();\n    std::cout &lt;&lt; \"list after deleting\" &lt;&lt; std::endl;\n    obj.deleteFromPosition(4);\n    obj.display();\n    return 0;\n}\nOutput :\nlist before modification\n12 24 36 48 94 \nlist after modification\n12 24 36 48 72 94 \nlist after deleting\n12 24 36 72 94",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "Linkedlist Basics"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/linkedlist_basics.html#double-linkedlist",
    "href": "C_Plus_Plus/Linked-list/linkedlist_basics.html#double-linkedlist",
    "title": "Linkedlist Basics",
    "section": "2 double linkedlist",
    "text": "2 double linkedlist\n\n\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n    Node *prev;\n\n    explicit Node(int data): data(data), next(nullptr),prev(nullptr){}\n\n    Node(int data, Node *next,Node* prev ): data(data), next(nullptr), prev(prev){}\n};\n\nclass doubleLinkedList\n{\npublic:\n    Node *head;\n\n    doubleLinkedList(): head(nullptr){}\n\n    void insertAtHead(int data)\n    {\n        if(head==nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            auto *newNode = new Node(data);\n            head-&gt;prev = newNode;\n            newNode-&gt;next = head;\n            head = newNode;\n            head-&gt;prev = nullptr;\n\n        }\n    }\n\n    void insertAtTail(int data)\n    {\n        if(head==nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node * temp=head;\n            while(temp-&gt;next!=nullptr)\n            {\n                temp=temp-&gt;next;\n            }\n            Node* newNode = new Node(data);\n            newNode-&gt;prev=temp;\n            temp-&gt;next=newNode;\n        }\n    }\n\n    void insertAtanyPosition(int data,int position)\n    {\n        if(head==nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            int currentPos=1;\n            Node * temp=head;\n            Node * previous=nullptr;\n            while(temp!=nullptr && currentPos&lt;position)\n            {\n                currentPos++;\n                temp=temp-&gt;next;\n            }\n\n            if(currentPos==position)\n            {\n                Node * newNode = new Node(data);\n                newNode-&gt;next=temp;\n                temp-&gt;prev-&gt;next=newNode;\n                newNode-&gt;prev=temp-&gt;prev;\n                temp-&gt;prev=newNode;\n            }\n        }\n    }\n\n    void deleteFromPosition(int position)\n    {\n            int currentPos=1;\n            Node * temp=head;\n            while(temp!=nullptr && currentPos&lt;position)\n            {\n                currentPos++;\n                temp=temp-&gt;next;\n            }\n\n            if(currentPos==position)\n            {\n                temp-&gt;prev-&gt;next=temp-&gt;next;\n                temp-&gt;next-&gt;prev=temp-&gt;prev;\n            }\n    }\n    void display() const\n    {\n        if(head==nullptr)\n        {\n            std::cout&lt;&lt;\"List is empty\"&lt;&lt;std::endl;\n        }\n        else\n        {\n            const Node * temp=head;\n            while(temp!=nullptr)\n            {\n                std::cout&lt;&lt;temp-&gt;data&lt;&lt;\" \";\n                temp=temp-&gt;next;\n            }\n            std::cout&lt;&lt;std::endl;\n        }\n\n    }\n\n    ~doubleLinkedList()\n    {\n        if(head!=nullptr)\n        {\n           const Node * temp=head;\n            while(temp!=nullptr)\n            {\n                const Node * nextNode=temp-&gt;next;\n                delete temp;\n                temp=nextNode;\n            }\n\n        }\n    }\n};\n\nint main()\n{\n    doubleLinkedList obj;\n    obj.insertAtHead(12);\n    obj.insertAtTail(24);\n    obj.insertAtHead(6);\n    obj.insertAtTail(36);\n    obj.insertAtTail(48);\n    obj.insertAtTail(94);\n    std::cout&lt;&lt;\"list before modification\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout&lt;&lt;\"list after modification\" &lt;&lt; std::endl;\n    obj.insertAtanyPosition(72,6);\n    obj.display();\n    std::cout&lt;&lt;\"list after deletion\" &lt;&lt; std::endl;\n    obj.deleteFromPosition(5);\n    obj.display();\n    return 0;\n}\nOutput:\nlist before modification\n6 12 24 36 48 94 \nlist after modification\n6 12 24 36 48 72 94 \nlist after deletion\n6 12 24 36 72 94",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "Linkedlist Basics"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/linkedlist_basics.html#reverse-single-linked-list",
    "href": "C_Plus_Plus/Linked-list/linkedlist_basics.html#reverse-single-linked-list",
    "title": "Linkedlist Basics",
    "section": "3 Reverse single linked list",
    "text": "3 Reverse single linked list\n#include &lt;iostream&gt;\n#include&lt;stack&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n            temp-&gt;next = new Node(data);\n        }\n    }\n\n    void reverseList()\n    {\n        Node *prev = nullptr;\n        Node *curr = head;\n        Node *next = head-&gt;next;\n        while (next != nullptr)\n        {\n            curr-&gt;next = prev;\n            prev = curr;\n            curr = next;\n            next = next-&gt;next;\n        }\n        curr-&gt;next = prev;\n        head = curr;\n    }\n\n    Node * reverseLeftToRight(Node * &headNode,int left,int right)\n    {\n        if (left == right) return headNode; // No need to reverse if left == right\n\n        Node* dummy = new Node(0);  // Dummy node to handle edge cases\n        dummy-&gt;next = headNode;\n        Node* prev = dummy;\n\n        // Move `prev` to the node just before `left`\n        for (int i = 1; i &lt; left; i++) {\n            prev = prev-&gt;next;\n        }\n\n        Node* start = prev-&gt;next;  // The first node in the section to be reversed\n        Node* temp = start;\n        std::stack&lt;Node*&gt; stk;\n\n        // Push nodes to be reversed onto the stack\n        for (int i = left; i &lt;= right; i++) {\n            stk.push(temp);\n            temp = temp-&gt;next;\n        }\n\n        // Pop from the stack and reverse the pointers\n        Node* nextNode = temp; // The node right after the section to be reversed\n        while (!stk.empty()) {\n            prev-&gt;next = stk.top();\n            stk.pop();\n            prev = prev-&gt;next;\n        }\n\n        // Connect the reversed part to the rest of the list\n        prev-&gt;next = nextNode;\n\n        return dummy-&gt;next;\n    }\n    void display(Node* head) const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    ~singleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp;\n                temp = nextNode;\n            }\n        }\n    }\n};\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtTail(24);\n    obj.insertAtTail(36);\n    obj.insertAtTail(48);\n    obj.insertAtTail(72);\n    std::cout &lt;&lt; \"list before reversal\" &lt;&lt; std::endl;\n    obj.display(obj.head);\n    obj.reverseList();\n    std::cout &lt;&lt; \"reversed list\" &lt;&lt; std::endl;\n    obj.display(obj.head);\n    std::cout &lt;&lt;\"reversed left to right\"&lt;&lt; std::endl;\n    Node* node=obj.reverseLeftToRight(obj.head,1,2);\n    obj.display(node);\n    return 0;\n}\nOutput:\nlist before reversal\n24 36 48 72 \nreversed list\n72 48 36 24 \nreversed left to right\n48 72 36 24",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "Linkedlist Basics"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/linkedlist_basics.html#double-linkedlist-reversal",
    "href": "C_Plus_Plus/Linked-list/linkedlist_basics.html#double-linkedlist-reversal",
    "title": "Linkedlist Basics",
    "section": "4 Double linkedlist reversal",
    "text": "4 Double linkedlist reversal\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n    Node *prev;\n\n    explicit Node(int data): data(data), next(nullptr), prev(nullptr)\n    {\n    }\n\n    Node(int data, Node *next, Node *prev): data(data), next(nullptr), prev(prev)\n    {\n    }\n};\n\nclass doubleLinkedList\n{\npublic:\n    Node *head;\n\n    doubleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n            Node *newNode = new Node(data);\n            newNode-&gt;prev = temp;\n            temp-&gt;next = newNode;\n        }\n    }\n\n    void reverseDoubleList()\n    {\n        if (head == nullptr)\n            return;\n        Node *curr = head;\n        Node *temp = nullptr;\n        while (curr != nullptr)\n        {\n            temp = curr-&gt;prev;\n            curr-&gt;prev = curr-&gt;next;\n            curr-&gt;next = temp;\n            curr = curr-&gt;prev;\n        }\n        if (temp != nullptr)\n        {\n            head = temp-&gt;prev;\n        }\n    }\n\n    void display() const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n\n    }\n\n    ~doubleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp;\n                temp = nextNode;\n            }\n\n        }\n    }\n};\n\nint main()\n{\n    doubleLinkedList obj;\n    obj.insertAtTail(24);\n    obj.insertAtTail(36);\n    obj.insertAtTail(48);\n    obj.insertAtTail(72);\n    std::cout &lt;&lt; \"linkedlist data \" &lt;&lt; std::endl;\n    obj.display();\n    obj.reverseDoubleList();\n    std::cout &lt;&lt; \"reversed list \" &lt;&lt; std::endl;\n    obj.display();\n    return 0;\n}\nlinkedlist data \n24 36 48 72 \nreversed list \n72 48 36 24",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "Linkedlist Basics"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/circular_linkedlist.html",
    "href": "C_Plus_Plus/Linked-list/circular_linkedlist.html",
    "title": "circularLinkedList",
    "section": "",
    "text": "#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtBeginning(int data)\n    {\n        auto *newNode = new Node(data);\n        if (head == nullptr)\n        {\n            head = newNode;\n            newNode-&gt;next = head;\n        }\n        else\n        {\n\n            Node *temp = head;\n            while (temp-&gt;next != head)\n            {\n                temp = temp-&gt;next;\n            }\n            temp-&gt;next = newNode;\n            newNode-&gt;next = head;\n            head = newNode;\n\n        }\n    }\n\n    void insertAtEnd(int data)\n    {\n        auto newNode = new Node(data);\n        if (head == nullptr)\n        {\n            head = newNode;\n            newNode-&gt;next = head;\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != head)\n            {\n                temp = temp-&gt;next;\n            }\n            temp-&gt;next = newNode;\n            newNode-&gt;next = head;\n        }\n    }\n\n    void createLinearToCircular(void)\n    {\n        if (head == nullptr)\n        {\n            return;\n        }\n\n        Node *temp = head;\n        while (temp-&gt;next != nullptr)\n        {\n            temp = temp-&gt;next;\n        }\n\n        temp-&gt;next = head;\n\n    }\n\n    void createCycleinTheList(int pos)\n    {\n        if (head == nullptr)\n        {\n            return;\n        }\n\n        int currPos = 1;\n        Node *temp = head;\n        Node *circNode = nullptr;\n        while (temp-&gt;next != nullptr)\n        {\n            if (currPos == pos)\n            {\n                circNode = temp;\n            }\n            currPos++;\n            temp = temp-&gt;next;\n        }\n        temp-&gt;next = circNode;\n\n    }\n\n    void findCycleinList()\n    {\n        if (head == nullptr)\n        {\n            return;\n        }\n        Node *fast = head;\n        Node *slow = head;\n        do\n        {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next;\n            fast = fast ? fast-&gt;next : fast;\n        } while (fast != nullptr && fast != slow);\n\n        if (fast == slow)\n        {\n            printf(\"The list is cyclic\\n\");\n        }\n    }\n\n    void display(bool isCircular) const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n            return;\n        }\n\n        const Node *temp = head;\n        if (isCircular)\n        {\n            do\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            } while (temp != head);\n        }\n        else\n        {\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n\n    ~singleLinkedList()\n    {\n        if (head == nullptr)\n            return;\n\n        Node *temp = head;\n\n        // Break the circular link, if any\n        Node *start = head;\n        while (temp-&gt;next != head && temp-&gt;next != nullptr) // Find the last node\n        {\n            temp = temp-&gt;next;\n        }\n        if (temp-&gt;next == head) // If the list is circular, break the loop\n        {\n            temp-&gt;next = nullptr;\n        }\n\n        // Delete the nodes as a normal singly linked list\n        temp = head;\n        while (temp != nullptr)\n        {\n            Node *nextNode = temp-&gt;next;\n            delete temp;\n            temp = nextNode;\n        }\n    }\n};\n\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtBeginning(12);\n    obj.insertAtEnd(24);\n    obj.insertAtEnd(36);\n    obj.insertAtEnd(48);\n    obj.insertAtEnd(94);\n    std::cout &lt;&lt; \"circular list\" &lt;&lt; std::endl;\n    obj.display(true);\n    obj.findCycleinList();\n    return 0;\n}\nOutput :\ncircular list\n12 24 36 48 94 \nThe list is cyclic",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "circularLinkedList"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/circular_linkedlist.html#circular-linkedlist",
    "href": "C_Plus_Plus/Linked-list/circular_linkedlist.html#circular-linkedlist",
    "title": "circularLinkedList",
    "section": "",
    "text": "#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtBeginning(int data)\n    {\n        auto *newNode = new Node(data);\n        if (head == nullptr)\n        {\n            head = newNode;\n            newNode-&gt;next = head;\n        }\n        else\n        {\n\n            Node *temp = head;\n            while (temp-&gt;next != head)\n            {\n                temp = temp-&gt;next;\n            }\n            temp-&gt;next = newNode;\n            newNode-&gt;next = head;\n            head = newNode;\n\n        }\n    }\n\n    void insertAtEnd(int data)\n    {\n        auto newNode = new Node(data);\n        if (head == nullptr)\n        {\n            head = newNode;\n            newNode-&gt;next = head;\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != head)\n            {\n                temp = temp-&gt;next;\n            }\n            temp-&gt;next = newNode;\n            newNode-&gt;next = head;\n        }\n    }\n\n    void createLinearToCircular(void)\n    {\n        if (head == nullptr)\n        {\n            return;\n        }\n\n        Node *temp = head;\n        while (temp-&gt;next != nullptr)\n        {\n            temp = temp-&gt;next;\n        }\n\n        temp-&gt;next = head;\n\n    }\n\n    void createCycleinTheList(int pos)\n    {\n        if (head == nullptr)\n        {\n            return;\n        }\n\n        int currPos = 1;\n        Node *temp = head;\n        Node *circNode = nullptr;\n        while (temp-&gt;next != nullptr)\n        {\n            if (currPos == pos)\n            {\n                circNode = temp;\n            }\n            currPos++;\n            temp = temp-&gt;next;\n        }\n        temp-&gt;next = circNode;\n\n    }\n\n    void findCycleinList()\n    {\n        if (head == nullptr)\n        {\n            return;\n        }\n        Node *fast = head;\n        Node *slow = head;\n        do\n        {\n            slow = slow-&gt;next;\n            fast = fast-&gt;next;\n            fast = fast ? fast-&gt;next : fast;\n        } while (fast != nullptr && fast != slow);\n\n        if (fast == slow)\n        {\n            printf(\"The list is cyclic\\n\");\n        }\n    }\n\n    void display(bool isCircular) const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n            return;\n        }\n\n        const Node *temp = head;\n        if (isCircular)\n        {\n            do\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            } while (temp != head);\n        }\n        else\n        {\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n\n    ~singleLinkedList()\n    {\n        if (head == nullptr)\n            return;\n\n        Node *temp = head;\n\n        // Break the circular link, if any\n        Node *start = head;\n        while (temp-&gt;next != head && temp-&gt;next != nullptr) // Find the last node\n        {\n            temp = temp-&gt;next;\n        }\n        if (temp-&gt;next == head) // If the list is circular, break the loop\n        {\n            temp-&gt;next = nullptr;\n        }\n\n        // Delete the nodes as a normal singly linked list\n        temp = head;\n        while (temp != nullptr)\n        {\n            Node *nextNode = temp-&gt;next;\n            delete temp;\n            temp = nextNode;\n        }\n    }\n};\n\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtBeginning(12);\n    obj.insertAtEnd(24);\n    obj.insertAtEnd(36);\n    obj.insertAtEnd(48);\n    obj.insertAtEnd(94);\n    std::cout &lt;&lt; \"circular list\" &lt;&lt; std::endl;\n    obj.display(true);\n    obj.findCycleinList();\n    return 0;\n}\nOutput :\ncircular list\n12 24 36 48 94 \nThe list is cyclic",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "circularLinkedList"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/circular_linkedlist.html#rotate-list-k-places",
    "href": "C_Plus_Plus/Linked-list/circular_linkedlist.html#rotate-list-k-places",
    "title": "circularLinkedList",
    "section": "2 Rotate list k places",
    "text": "2 Rotate list k places\n\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtHead(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            auto *newNode = new Node(data);\n            newNode-&gt;next = head;\n            head = newNode;\n\n        }\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n\n            temp-&gt;next = new Node(data);\n        }\n    }\n\n    Node *rotateKtimes(Node *head, int k)\n    {\n        if (head == nullptr || k == 0 || head-&gt;next == nullptr)\n            return head;\n\n        int length = 1;\n        Node *tail = head;\n        while (tail-&gt;next != nullptr)\n        {\n            tail = tail-&gt;next;\n            length++;\n        }\n\n        k = k % length;\n        if (k == 0)\n            return head;\n\n        tail-&gt;next = head;\n\n        Node *newTail = head;\n        for (int i = 1; i &lt; length - k; ++i)\n        {\n            newTail = newTail-&gt;next;\n        }\n\n        Node *newHead = newTail-&gt;next;\n        newTail-&gt;next = nullptr;\n\n        return newHead;\n    }\n\n    void display(Node *head) const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n\n    }\n\n    ~singleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp;\n                temp = nextNode;\n            }\n\n        }\n    }\n};\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtHead(12);\n    obj.insertAtTail(24);\n    obj.insertAtTail(36);\n    obj.insertAtTail(48);\n    obj.insertAtTail(94);\n    std::cout &lt;&lt; \"list before modification\" &lt;&lt; std::endl;\n    obj.display(obj.head);\n    Node *node = obj.rotateKtimes(obj.head, 2);\n    std::cout &lt;&lt; \"rotated List\" &lt;&lt; std::endl;\n    obj.display(node);\n    return 0;\n}\nProblem statement : \nGiven the head of a linked list, rotate the list to the right by k places.\nOutput:\nlist before modification\n12 24 36 48 94 \nrotated List\n48 94 12 24 36",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "circularLinkedList"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binarySearchTree.html",
    "href": "C_Plus_Plus/Trees/binarySearchTree.html",
    "title": "binary search Tree",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;cmath&gt;\n#include&lt;iomanip&gt;\n\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass BST\n{\npublic:\n    Node *root;\n\n    BST(): root(nullptr)\n    {\n    }\n\n\n    void createBST(int data)\n    {\n        Node *newNode = new Node(data);\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        Node *curr = root;\n        Node *prev = nullptr;\n        while (curr != nullptr)\n        {\n            prev = curr;\n            if (curr-&gt;data &gt; newNode-&gt;data)\n            {\n                curr = curr-&gt;leftChild;\n\n            }\n            else\n            {\n                curr = curr-&gt;rightChild;\n            }\n\n        }\n\n        if (prev-&gt;data &gt; newNode-&gt;data)\n        {\n            prev-&gt;leftChild = newNode;\n        }\n        else\n        {\n            prev-&gt;rightChild = newNode;;\n        }\n\n    }\n\n    int count(Node *root)\n    {\n        if (root == nullptr)\n            return 0;\n        const int x = count(root-&gt;leftChild);\n        const int y = count(root-&gt;rightChild);\n        return x + y + 1;\n    }\n\n    void display() const\n    {\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n            return;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            auto curr = q.front();\n            q.pop();\n            std::cout &lt;&lt; curr-&gt;data &lt;&lt; \" \";\n            if (curr-&gt;leftChild != nullptr)\n                q.push(curr-&gt;leftChild);\n            if (curr-&gt;rightChild != nullptr)\n                q.push(curr-&gt;rightChild);\n        }\n    }\n\n    int calculateHeight(Node *root)\n    {\n        if (!root)\n            return 0;\n        int leftHeight = calculateHeight(root-&gt;leftChild);\n        int rightHeight = calculateHeight(root-&gt;rightChild);\n        return std::max(leftHeight, rightHeight) + 1;\n    }\n\n    void printTree(Node *root)\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n            return;\n        }\n\n        int height = calculateHeight(root); // Calculate the tree's height\n        int maxWidth = pow(2, height) - 1; // Maximum number of nodes in the last level\n        int levelSpacing = 3; // Base spacing between nodes\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        for (int level = 0; level &lt; height; ++level)\n        {\n            int levelSize = q.size();\n            int spacesBefore = (maxWidth / pow(2, level + 1)) * levelSpacing; // Spaces before first node\n            int spacesBetween = spacesBefore * 2; // Spaces between nodes\n\n            // Print leading spaces for the level\n            std::cout &lt;&lt; std::string(spacesBefore, ' ');\n\n            for (int i = 0; i &lt; levelSize; ++i)\n            {\n                Node *current = q.front();\n                q.pop();\n\n                if (current)\n                {\n                    std::cout &lt;&lt; current-&gt;data;\n                    q.push(current-&gt;leftChild);\n                    q.push(current-&gt;rightChild);\n                }\n                else\n                {\n                    std::cout &lt;&lt; \" \"; // Placeholder for missing nodes\n                    q.push(nullptr);\n                    q.push(nullptr);\n                }\n\n                // Print spaces between nodes\n                std::cout &lt;&lt; std::string(spacesBetween, ' ');\n            }\n\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    ~BST()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    BST obj;\n    obj.createBST(10);\n    obj.createBST(6);\n    obj.createBST(15);\n    obj.createBST(4);\n    obj.createBST(8);\n    obj.createBST(12);\n    obj.createBST(18);\n    std::cout &lt;&lt; \"Binary search tree elements\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n    const auto count = obj.count(obj.root);\n    std::cout &lt;&lt; \"No of nodes: \" &lt;&lt; count &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Binary Search tree\" &lt;&lt; std::endl;\n    obj.printTree(obj.root);\n    return 0;\n}\nOutput :\n\nBinary search tree elements\n10 6 15 4 8 12 18 \n\nNo of nodes: 7\n\nBinary Search tree\n          10                    \n     6          15          \n  4    8    12    18",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary search Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binarySearchTree.html#binary-search-tree-creation",
    "href": "C_Plus_Plus/Trees/binarySearchTree.html#binary-search-tree-creation",
    "title": "binary search Tree",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;cmath&gt;\n#include&lt;iomanip&gt;\n\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass BST\n{\npublic:\n    Node *root;\n\n    BST(): root(nullptr)\n    {\n    }\n\n\n    void createBST(int data)\n    {\n        Node *newNode = new Node(data);\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        Node *curr = root;\n        Node *prev = nullptr;\n        while (curr != nullptr)\n        {\n            prev = curr;\n            if (curr-&gt;data &gt; newNode-&gt;data)\n            {\n                curr = curr-&gt;leftChild;\n\n            }\n            else\n            {\n                curr = curr-&gt;rightChild;\n            }\n\n        }\n\n        if (prev-&gt;data &gt; newNode-&gt;data)\n        {\n            prev-&gt;leftChild = newNode;\n        }\n        else\n        {\n            prev-&gt;rightChild = newNode;;\n        }\n\n    }\n\n    int count(Node *root)\n    {\n        if (root == nullptr)\n            return 0;\n        const int x = count(root-&gt;leftChild);\n        const int y = count(root-&gt;rightChild);\n        return x + y + 1;\n    }\n\n    void display() const\n    {\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n            return;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            auto curr = q.front();\n            q.pop();\n            std::cout &lt;&lt; curr-&gt;data &lt;&lt; \" \";\n            if (curr-&gt;leftChild != nullptr)\n                q.push(curr-&gt;leftChild);\n            if (curr-&gt;rightChild != nullptr)\n                q.push(curr-&gt;rightChild);\n        }\n    }\n\n    int calculateHeight(Node *root)\n    {\n        if (!root)\n            return 0;\n        int leftHeight = calculateHeight(root-&gt;leftChild);\n        int rightHeight = calculateHeight(root-&gt;rightChild);\n        return std::max(leftHeight, rightHeight) + 1;\n    }\n\n    void printTree(Node *root)\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n            return;\n        }\n\n        int height = calculateHeight(root); // Calculate the tree's height\n        int maxWidth = pow(2, height) - 1; // Maximum number of nodes in the last level\n        int levelSpacing = 3; // Base spacing between nodes\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        for (int level = 0; level &lt; height; ++level)\n        {\n            int levelSize = q.size();\n            int spacesBefore = (maxWidth / pow(2, level + 1)) * levelSpacing; // Spaces before first node\n            int spacesBetween = spacesBefore * 2; // Spaces between nodes\n\n            // Print leading spaces for the level\n            std::cout &lt;&lt; std::string(spacesBefore, ' ');\n\n            for (int i = 0; i &lt; levelSize; ++i)\n            {\n                Node *current = q.front();\n                q.pop();\n\n                if (current)\n                {\n                    std::cout &lt;&lt; current-&gt;data;\n                    q.push(current-&gt;leftChild);\n                    q.push(current-&gt;rightChild);\n                }\n                else\n                {\n                    std::cout &lt;&lt; \" \"; // Placeholder for missing nodes\n                    q.push(nullptr);\n                    q.push(nullptr);\n                }\n\n                // Print spaces between nodes\n                std::cout &lt;&lt; std::string(spacesBetween, ' ');\n            }\n\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    ~BST()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    BST obj;\n    obj.createBST(10);\n    obj.createBST(6);\n    obj.createBST(15);\n    obj.createBST(4);\n    obj.createBST(8);\n    obj.createBST(12);\n    obj.createBST(18);\n    std::cout &lt;&lt; \"Binary search tree elements\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n    const auto count = obj.count(obj.root);\n    std::cout &lt;&lt; \"No of nodes: \" &lt;&lt; count &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Binary Search tree\" &lt;&lt; std::endl;\n    obj.printTree(obj.root);\n    return 0;\n}\nOutput :\n\nBinary search tree elements\n10 6 15 4 8 12 18 \n\nNo of nodes: 7\n\nBinary Search tree\n          10                    \n     6          15          \n  4    8    12    18",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary search Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binarySearchTree.html#binary-search-tree-node-deletion",
    "href": "C_Plus_Plus/Trees/binarySearchTree.html#binary-search-tree-node-deletion",
    "title": "binary search Tree",
    "section": "2 Binary Search Tree Node deletion",
    "text": "2 Binary Search Tree Node deletion\n#include &lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;cmath&gt;\n#include&lt;iomanip&gt;\n\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass BST\n{\npublic:\n    Node *root;\n\n    BST(): root(nullptr)\n    {\n    }\n\n\n    void createBST(int data)\n    {\n        Node *newNode = new Node(data);\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        Node *curr = root;\n        Node *prev = nullptr;\n        while (curr != nullptr)\n        {\n            prev = curr;\n            if (curr-&gt;data &gt; newNode-&gt;data)\n            {\n                curr = curr-&gt;leftChild;\n\n            }\n            else\n            {\n                curr = curr-&gt;rightChild;\n            }\n\n        }\n\n        if (prev-&gt;data &gt; newNode-&gt;data)\n        {\n            prev-&gt;leftChild = newNode;\n        }\n        else\n        {\n            prev-&gt;rightChild = newNode;;\n        }\n\n    }\n\n    int count(Node *root)\n    {\n        if (root == nullptr)\n            return 0;\n        const int x = count(root-&gt;leftChild);\n        const int y = count(root-&gt;rightChild);\n        return x + y + 1;\n    }\n\n    void display() const\n    {\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n            return;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            auto curr = q.front();\n            q.pop();\n            std::cout &lt;&lt; curr-&gt;data &lt;&lt; \" \";\n            if (curr-&gt;leftChild != nullptr)\n                q.push(curr-&gt;leftChild);\n            if (curr-&gt;rightChild != nullptr)\n                q.push(curr-&gt;rightChild);\n        }\n    }\n\n    int calculateHeight(Node *root)\n    {\n        if (!root)\n            return 0;\n        int leftHeight = calculateHeight(root-&gt;leftChild);\n        int rightHeight = calculateHeight(root-&gt;rightChild);\n        return std::max(leftHeight, rightHeight) + 1;\n    }\n\n    void printTree(Node *root)\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n            return;\n        }\n\n        int height = calculateHeight(root); // Calculate the tree's height\n        int maxWidth = pow(2, height) - 1; // Maximum number of nodes in the last level\n        int levelSpacing = 3; // Base spacing between nodes\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        for (int level = 0; level &lt; height; ++level)\n        {\n            int levelSize = q.size();\n            int spacesBefore = (maxWidth / pow(2, level + 1)) * levelSpacing; // Spaces before first node\n            int spacesBetween = spacesBefore * 2; // Spaces between nodes\n\n            // Print leading spaces for the level\n            std::cout &lt;&lt; std::string(spacesBefore, ' ');\n\n            for (int i = 0; i &lt; levelSize; ++i)\n            {\n                Node *current = q.front();\n                q.pop();\n\n                if (current)\n                {\n                    std::cout &lt;&lt; current-&gt;data;\n                    q.push(current-&gt;leftChild);\n                    q.push(current-&gt;rightChild);\n                }\n                else\n                {\n                    std::cout &lt;&lt; \" \"; // Placeholder for missing nodes\n                    q.push(nullptr);\n                    q.push(nullptr);\n                }\n\n                // Print spaces between nodes\n                std::cout &lt;&lt; std::string(spacesBetween, ' ');\n            }\n\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    Node *inOrderPrecessor(Node *node)\n    {\n        while (node != nullptr && node-&gt;rightChild != nullptr)\n        {\n            node = node-&gt;rightChild;\n        }\n        return node;\n    }\n\n    Node *inOrderSuccessor(Node *node)\n    {\n        while (node != nullptr && node-&gt;leftChild != nullptr)\n        {\n            node = node-&gt;leftChild;\n        }\n        return node;\n    }\n\n    Node *deleteNode(Node *node, int value)\n    {\n        if (node == nullptr)\n            return nullptr;\n\n        if (node-&gt;leftChild == nullptr && node-&gt;rightChild == nullptr)\n        {\n            if (node == root)\n            {\n                root = nullptr;\n            }\n            delete node;\n            return nullptr;\n        }\n\n        if (node-&gt;data &gt; value)\n        {\n            node-&gt;leftChild = deleteNode(node-&gt;leftChild, value);\n        }\n        else if (node-&gt;data &lt; value)\n        {\n            node-&gt;rightChild = deleteNode(node-&gt;rightChild, value);\n        }\n        else\n        {\n            if (calculateHeight(node-&gt;leftChild) &gt; calculateHeight(node-&gt;rightChild))\n            {\n                auto temp = inOrderPrecessor(node-&gt;leftChild);\n                int newValue = temp-&gt;data;\n                node-&gt;data = temp-&gt;data;\n                node-&gt;leftChild = deleteNode(node-&gt;leftChild, newValue);\n            }\n            else\n            {\n                auto temp = inOrderPrecessor(node-&gt;rightChild);\n                int newValue = temp-&gt;data;\n                node-&gt;data = temp-&gt;data;\n                node-&gt;rightChild = deleteNode(node-&gt;rightChild, newValue);\n            }\n        }\n        return node;\n    }\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    ~BST()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    BST obj;\n    obj.createBST(10);\n    obj.createBST(6);\n    obj.createBST(15);\n    obj.createBST(4);\n    obj.createBST(8);\n    obj.createBST(12);\n    obj.createBST(18);\n    std::cout &lt;&lt; \"Binary search tree elements\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n    const auto count = obj.count(obj.root);\n    std::cout &lt;&lt; \"No of nodes: \" &lt;&lt; count &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Binary Search tree\" &lt;&lt; std::endl;\n    obj.printTree(obj.root);\n\n    auto node = obj.deleteNode(obj.root, 6);\n    std::cout &lt;&lt; \"Binary Search tree after Delete \" &lt;&lt; std::endl;\n    obj.printTree(node);\n    return 0;\n}\nOutput:\nBinary search tree elements\n10 6 15 4 8 12 18 \n\nNo of nodes: 7\n\nBinary Search tree\n          10                    \n     6          15          \n  4    8    12    18   \n\nBinary Search tree after Delete \n          10                    \n     8          15          \n  4         12    18",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary search Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binarySearchTree.html#binary-search-tree-generation-using-preorder-traversal-list",
    "href": "C_Plus_Plus/Trees/binarySearchTree.html#binary-search-tree-generation-using-preorder-traversal-list",
    "title": "binary search Tree",
    "section": "3 Binary Search Tree generation using PreOrder Traversal list",
    "text": "3 Binary Search Tree generation using PreOrder Traversal list\n#include &lt;iostream&gt;\n#include&lt;queue&gt;\n#include&lt;cmath&gt;\n#include&lt;iomanip&gt;\n\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass BST\n{\npublic:\n    Node *root;\n\n    BST(): root(nullptr)\n    {\n    }\n\n\n    void createBST(int data)\n    {\n        Node *newNode = new Node(data);\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        Node *curr = root;\n        Node *prev = nullptr;\n        while (curr != nullptr)\n        {\n            prev = curr;\n            if (curr-&gt;data &gt; newNode-&gt;data)\n            {\n                curr = curr-&gt;leftChild;\n\n            }\n            else\n            {\n                curr = curr-&gt;rightChild;\n            }\n\n        }\n\n        if (prev-&gt;data &gt; newNode-&gt;data)\n        {\n            prev-&gt;leftChild = newNode;\n        }\n        else\n        {\n            prev-&gt;rightChild = newNode;;\n        }\n\n    }\n\n    int count(Node *root)\n    {\n        if (root == nullptr)\n            return 0;\n        const int x = count(root-&gt;leftChild);\n        const int y = count(root-&gt;rightChild);\n        return x + y + 1;\n    }\n\n    void display() const\n    {\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n            return;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            auto curr = q.front();\n            q.pop();\n            std::cout &lt;&lt; curr-&gt;data &lt;&lt; \" \";\n            if (curr-&gt;leftChild != nullptr)\n                q.push(curr-&gt;leftChild);\n            if (curr-&gt;rightChild != nullptr)\n                q.push(curr-&gt;rightChild);\n        }\n    }\n\n    int calculateHeight(Node *root)\n    {\n        if (!root)\n            return 0;\n        int leftHeight = calculateHeight(root-&gt;leftChild);\n        int rightHeight = calculateHeight(root-&gt;rightChild);\n        return std::max(leftHeight, rightHeight) + 1;\n    }\n\n    void printTree(Node *root)\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n            return;\n        }\n\n        int height = calculateHeight(root); // Calculate the tree's height\n        int maxWidth = pow(2, height) - 1; // Maximum number of nodes in the last level\n        int levelSpacing = 3; // Base spacing between nodes\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        for (int level = 0; level &lt; height; ++level)\n        {\n            int levelSize = q.size();\n            int spacesBefore = (maxWidth / pow(2, level + 1)) * levelSpacing; // Spaces before first node\n            int spacesBetween = spacesBefore * 2; // Spaces between nodes\n\n            // Print leading spaces for the level\n            std::cout &lt;&lt; std::string(spacesBefore, ' ');\n\n            for (int i = 0; i &lt; levelSize; ++i)\n            {\n                Node *current = q.front();\n                q.pop();\n\n                if (current)\n                {\n                    std::cout &lt;&lt; current-&gt;data;\n                    q.push(current-&gt;leftChild);\n                    q.push(current-&gt;rightChild);\n                }\n                else\n                {\n                    std::cout &lt;&lt; \" \"; // Placeholder for missing nodes\n                    q.push(nullptr);\n                    q.push(nullptr);\n                }\n\n                // Print spaces between nodes\n                std::cout &lt;&lt; std::string(spacesBetween, ' ');\n            }\n\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    void preOrderHelper(Node *root, std::vector&lt;int&gt; &vec)\n    {\n        if (!root)\n            return;\n\n        vec.push_back(root-&gt;data);\n        preOrderHelper(root-&gt;leftChild, vec);\n        preOrderHelper(root-&gt;rightChild, vec);\n\n    }\n\n    std::vector&lt;int&gt; preOrder(Node *root)\n    {\n        std::vector&lt;int&gt; vec;\n        preOrderHelper(root, vec);\n        return vec;\n    }\n\n    Node *TreeGenerationFromPreOrder(std::vector&lt;int&gt; &pre)\n    {\n        std::stack&lt;Node *&gt; stk;\n        static int i = 0;\n        Node *newNode = new Node(pre[i++]);\n        Node *rootModified = newNode;\n        while (i &lt; pre.size())\n        {\n            if (newNode-&gt;data &gt; pre[i])\n            {\n                stk.push(newNode);\n                newNode-&gt;leftChild = new Node(pre[i++]);\n                newNode = newNode-&gt;leftChild;\n            }\n            else if (newNode-&gt;data &lt; pre[i] && !stk.empty() && stk.top()-&gt;data &gt; pre[i])\n            {\n                newNode-&gt;rightChild = new Node(pre[i++]);\n                newNode = newNode-&gt;rightChild;\n            }\n            else\n            {\n                if (!stk.empty())\n                {\n                    newNode = stk.top();\n                    stk.pop();\n\n                }\n                else\n                {\n                    newNode-&gt;rightChild = new Node(pre[i++]);\n                    newNode = newNode-&gt;rightChild;\n                }\n            }\n        }\n        return rootModified;\n\n    }\n\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    ~BST()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    BST obj;\n    obj.createBST(10);\n    obj.createBST(6);\n    obj.createBST(15);\n    obj.createBST(4);\n    obj.createBST(8);\n    obj.createBST(12);\n    obj.createBST(18);\n    std::cout &lt;&lt; \"Binary search tree elements\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n    const auto count = obj.count(obj.root);\n    std::cout &lt;&lt; \"No of nodes: \" &lt;&lt; count &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Binary Search tree\" &lt;&lt; std::endl;\n    obj.printTree(obj.root);\n\n    auto pre = obj.preOrder(obj.root);\n    std::cout &lt;&lt; \"preOrder list\" &lt;&lt; std::endl;\n    for (auto i : pre)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n\n    auto node = obj.TreeGenerationFromPreOrder(pre);\n\n    std::cout &lt;&lt; \"Binary Search tree generated from Preorder\" &lt;&lt; std::endl;\n    obj.printTree(node);\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\nOutput:\nBinary search tree elements\n10 6 15 4 8 12 18 \n\nNo of nodes: 7\n\nBinary Search tree\n          10                    \n     6          15          \n  4    8    12    18   \n\npreOrder list\n10 6 4 8 15 12 18 \n\nBinary Search tree generated from Preorder\n          10                    \n     6          15          \n  4    8    12    18",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary search Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Queue/queue.html",
    "href": "C_Plus_Plus/Queue/queue.html",
    "title": "Queue in C++",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;new&gt;\n\nclass Node\n{\n    public:\n    int data;\n    Node* next;\n    Node(int data):data(data), next(nullptr) {};\n};\n\nclass Queue\n{\n    public:\n    Node* head;\n    Node* tail;\n    Queue():head(nullptr), tail(nullptr) {}\n    void enqueueData(int data)\n    {\n        Node* newNode = new (std::nothrow) Node(data);\n        if (newNode == nullptr) {\n            printf(\"Queue is full\");\n            return;\n        }\n        if (head == nullptr) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail-&gt;next = newNode;\n            tail = newNode;\n        }\n    }\n\n    int deQeueuData()\n    {  \n        if (head == nullptr) {\n            printf(\"Queue is empty\");\n            return -1;\n        }     \n        Node * tempNode = head;\n        int temp = tempNode-&gt;data;\n        head = head-&gt;next;\n        if (head == nullptr) {\n            tail = nullptr;\n        }\n        delete tempNode;\n        return temp;\n    }\n    ~Queue(){\n        Node * temp = head;\n        while (temp != nullptr) {\n            Node* deleteNode = temp;\n            temp = temp-&gt;next;\n            delete deleteNode;\n        }\n    }\n\n    void display() {\n        Node* temp = head;\n        while(temp != nullptr) {\n            printf(\"\\n data = %d\",temp-&gt;data);\n            temp = temp-&gt;next;\n        }\n    }    \n};\n \nint main()\n{\n    Queue obj;\n    obj.enqueueData(4);\n    obj.enqueueData(5);\n    obj.enqueueData(6);\n    obj.enqueueData(7);\n    obj.deQeueuData();\n    obj.display();\n}\nOutput :\ndata = 5\ndata = 6 \ndata = 7",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Queue",
      "Queue in C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Queue/queue.html#queue",
    "href": "C_Plus_Plus/Queue/queue.html#queue",
    "title": "Queue in C++",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include &lt;new&gt;\n\nclass Node\n{\n    public:\n    int data;\n    Node* next;\n    Node(int data):data(data), next(nullptr) {};\n};\n\nclass Queue\n{\n    public:\n    Node* head;\n    Node* tail;\n    Queue():head(nullptr), tail(nullptr) {}\n    void enqueueData(int data)\n    {\n        Node* newNode = new (std::nothrow) Node(data);\n        if (newNode == nullptr) {\n            printf(\"Queue is full\");\n            return;\n        }\n        if (head == nullptr) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail-&gt;next = newNode;\n            tail = newNode;\n        }\n    }\n\n    int deQeueuData()\n    {  \n        if (head == nullptr) {\n            printf(\"Queue is empty\");\n            return -1;\n        }     \n        Node * tempNode = head;\n        int temp = tempNode-&gt;data;\n        head = head-&gt;next;\n        if (head == nullptr) {\n            tail = nullptr;\n        }\n        delete tempNode;\n        return temp;\n    }\n    ~Queue(){\n        Node * temp = head;\n        while (temp != nullptr) {\n            Node* deleteNode = temp;\n            temp = temp-&gt;next;\n            delete deleteNode;\n        }\n    }\n\n    void display() {\n        Node* temp = head;\n        while(temp != nullptr) {\n            printf(\"\\n data = %d\",temp-&gt;data);\n            temp = temp-&gt;next;\n        }\n    }    \n};\n \nint main()\n{\n    Queue obj;\n    obj.enqueueData(4);\n    obj.enqueueData(5);\n    obj.enqueueData(6);\n    obj.enqueueData(7);\n    obj.deQeueuData();\n    obj.display();\n}\nOutput :\ndata = 5\ndata = 6 \ndata = 7",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Queue",
      "Queue in C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Queue/queue.html#priority-queue",
    "href": "C_Plus_Plus/Queue/queue.html#priority-queue",
    "title": "Queue in C++",
    "section": "2 Priority Queue",
    "text": "2 Priority Queue\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include&lt;vector&gt;\n#include &lt;cstdio&gt;\n\nclass Node\n{\n    public:\n    int data;\n    Node* next;\n    Node(int data):data(data), next(nullptr) {};\n};\n\nclass Queue\n{\n    public:\n    Node* head;\n    Node* tail;\n    Queue():head(nullptr), tail(nullptr) {}\n    void enqueueData(int data)\n    {\n        Node* newNode = new Node(data);\n        if (newNode == nullptr) {\n            printf(\"Queue is full\");\n            return;\n        }\n        if (head == nullptr) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail-&gt;next = newNode;\n            tail = newNode;\n        }\n    }\n\n    int deQeueuData()\n    {  \n        if (head == nullptr) {\n            printf(\"Queue is empty\");\n            return -1;\n        }     \n        Node * tempNode = head;\n        int temp = tempNode-&gt;data;\n        head = head-&gt;next;\n        if (head == nullptr) {\n            tail = nullptr;\n        }\n        delete tempNode;\n        return temp;\n    }\n    ~Queue(){\n        Node * temp = head;\n        while (temp != nullptr) {\n            Node* deleteNode = temp;\n            temp = temp-&gt;next;\n            delete deleteNode;\n        }\n    }\n\n    void display() {\n        Node* temp = head;\n        while(temp != nullptr) {\n            printf(\"\\n data = %d\",temp-&gt;data);\n            temp = temp-&gt;next;\n        }\n    }\n    \n};\n\n// Priority Queue lower number highest priority.\n\nclass PriorityQueue\n{\n    public:\n    // Priority range [0..MAX_PRIORITY]; smaller number = higher priority\n    static const int MAX_PRIORITY = 9; // adjust as needed\n    Queue buckets[MAX_PRIORITY + 1];\n\n    PriorityQueue() {}\n\n    void enqueue(int data, int priority)\n    {\n        if (priority &lt; 0) priority = 0;\n        if (priority &gt; MAX_PRIORITY) priority = MAX_PRIORITY;\n        buckets[priority].enqueueData(data);\n    }\n\n    int dequeue()\n    {\n        // Scan from smallest (highest priority) to largest\n        for (int p = 0; p &lt;= MAX_PRIORITY; ++p) {\n            if (buckets[p].head != nullptr) {\n                return buckets[p].deQeueuData();\n            }\n        }\n        printf(\"PriorityQueue is empty\");\n        return -1;\n    }\n\n    bool isEmpty()\n    {\n        for (int p = 0; p &lt;= MAX_PRIORITY; ++p) {\n            if (buckets[p].head != nullptr) return false;\n        }\n        return true;\n    }\n\n    void display()\n    {\n        // Show higher priority first (i.e., smaller numbers first)\n        for (int p = 0; p &lt;= MAX_PRIORITY; ++p) {\n            if (buckets[p].head != nullptr) {\n                printf(\"\\nPriority %d:\", p);\n                buckets[p].display();\n                printf(\"\\n\");\n            }\n        }\n    }\n};\n\n \nint main()\n{\n    // Basic Queue demo\n    Queue obj;\n    obj.enqueueData(4);\n    obj.enqueueData(5);\n    obj.enqueueData(6);\n    obj.enqueueData(7);\n    obj.deQeueuData();\n    obj.display();\n\n    printf(\"\\n\\n---- PriorityQueue demo (smaller number = higher priority) ----\\n\");\n\n    PriorityQueue pq;\n    // enqueue(value, priority). Smaller priority number dequeues first.\n    pq.enqueue(100, 3);\n    pq.enqueue(200, 1);\n    pq.enqueue(300, 5);\n    pq.enqueue(400, 0);\n    pq.enqueue(500, 1);\n\n    printf(\"PriorityQueue contents by priority:\");\n    pq.display();\n\n    printf(\"\\nDequeue order (should be 400, 200, 500, 100, 300):\\n\");\n    int x = pq.dequeue();\n    printf(\"Deqeued element %d\\n\", x);\n    printf(\"Rest of the elements in the Priority Queue\");\n    pq.display();\n}\noutput:\n---- PriorityQueue demo (smaller number = higher priority) ----\nPriorityQueue contents by priority:\nPriority 0:\n data = 400\n\nPriority 1:\n data = 200\n data = 500\n\nPriority 3:\n data = 100\n\nPriority 5:\n data = 300\n\nDequeue order (should be 400, 200, 500, 100, 300):\nDeqeued element 400\nRest of the elements in the Priority Queue\nPriority 1:\n data = 200\n data = 500\n\nPriority 3:\n data = 100\n\nPriority 5:\n data = 300\n\n#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;new&gt;\n\nclass Node\n{\n    public:\n    int data;\n    Node* next;\n    Node(int data):data(data), next(nullptr) {};\n};\n\nclass Stack\n{\n    public:\n    Node* head;\n    Stack():head(nullptr) {}\n    void push(int data)\n    {\n        Node* newNode = new (std::nothrow) Node(data);\n        if (newNode == nullptr) {\n            printf(\"Stack is full\");\n            return;\n        }\n        if (head == nullptr) {\n            head = newNode;\n        } else {\n            newNode-&gt;next = head;\n            head = newNode;\n        }\n    }\n\n    int pop()\n    {  \n        if (head == nullptr) {\n            printf(\"Stack is empty\");\n            return -1;\n        }     \n        Node * tempNode = head;\n        int temp = tempNode-&gt;data;\n        head = head-&gt;next;\n        delete tempNode;\n        return temp;\n    }\n    ~Stack(){\n        Node * temp = head;\n        while (temp != nullptr) {\n            Node* deleteNode = temp;\n            temp = temp-&gt;next;\n            delete deleteNode;\n        }\n    }\n\n    void display() {\n        Node* temp = head;\n        while(temp != nullptr) {\n            printf(\"\\n data = %d\",temp-&gt;data);\n            temp = temp-&gt;next;\n        }\n    }\n    \n};\n\nclass Queue \n{\n    public:\n    Stack stack1;\n    Stack stack2;\n\n    void enqueue(int data) {\n        stack1.push(data);\n    }\n\n    int dequeue() {\n        if (stack2.head == nullptr) {\n            while (stack1.head != nullptr) {\n                int data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        if (stack2.head == nullptr) {\n            printf(\"Queue is empty\");\n            return -1;\n        }\n        return stack2.pop();\n    }\n\n    bool isEmpty() {\n        return (stack1.head == nullptr && stack2.head == nullptr);\n    }\n\n    void display() {       \n        stack2.display();       \n        stack1.display();        \n    }\n};\n \nint main()\n{\n    Queue obj;\n    obj.enqueue(4);\n    obj.enqueue(5);\n    obj.enqueue(6);\n    obj.enqueue(7);\n    obj.dequeue();\n    obj.enqueue(8);\n    obj.display();\n}\noutput:\ndata = 5\ndata = 6\ndata = 7\ndata = 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Queue",
      "Queue in C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html",
    "href": "C_Plus_Plus/Sorting/sorting.html",
    "title": "Sorting Algorithms",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nvoid bubbleSort(std::vector&lt;int&gt; &v)\n{\n    for (int i = 0; i &lt; v.size(); i++)\n    {\n        for (int j = 0; j &lt; v.size() - 1 - i; j++)\n        {\n            if (v[j] &gt; v[j + 1])\n            {\n                std::swap(v[j], v[j + 1]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    bubbleSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Bubble sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\nOutput:\nSorted elements with Bubble sort: 1 2 3 4 5 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#bubble-sort",
    "href": "C_Plus_Plus/Sorting/sorting.html#bubble-sort",
    "title": "Sorting Algorithms",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nvoid bubbleSort(std::vector&lt;int&gt; &v)\n{\n    for (int i = 0; i &lt; v.size(); i++)\n    {\n        for (int j = 0; j &lt; v.size() - 1 - i; j++)\n        {\n            if (v[j] &gt; v[j + 1])\n            {\n                std::swap(v[j], v[j + 1]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    bubbleSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Bubble sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\nOutput:\nSorted elements with Bubble sort: 1 2 3 4 5 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#insertion-sort",
    "href": "C_Plus_Plus/Sorting/sorting.html#insertion-sort",
    "title": "Sorting Algorithms",
    "section": "2 Insertion sort",
    "text": "2 Insertion sort\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nvoid insertionSort(std::vector&lt;int&gt; &v)\n{\n    for (int i = 1; i &lt; v.size(); i++)\n    {\n        const int x = v[i];\n        int j = i - 1;\n        while (j &gt;= 0 && v[j] &gt; x)\n        {\n            v[j + 1] = v[j];\n            j--;\n        }\n        v[j + 1] = x;\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    insertionSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Insertion sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\nOutput:\nSorted elements with Insertion sort: 1 2 3 4 5 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#selection-sort",
    "href": "C_Plus_Plus/Sorting/sorting.html#selection-sort",
    "title": "Sorting Algorithms",
    "section": "3 Selection sort",
    "text": "3 Selection sort\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nvoid selectionSort(std::vector&lt;int&gt; &v)\n{\n    for (int i = 0; i &lt; v.size(); i++)\n    {\n        int minIndex = i;\n        for (int j = i + 1; j &lt; v.size(); j++)\n        {\n            if (v[j] &lt; v[minIndex])\n            {\n                minIndex = j;\n            }\n        }\n        std::swap(v[i], v[minIndex]);\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    selectionSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Selection sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\n\nOutput:\nSorted elements with Selection sort: 1 2 3 4 5 8 \n\nNote:\nWith selection sort after one pass the smallest numbers goes to start of the vector",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#quicksort",
    "href": "C_Plus_Plus/Sorting/sorting.html#quicksort",
    "title": "Sorting Algorithms",
    "section": "4 QuickSort",
    "text": "4 QuickSort\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nint partition(std::vector&lt;int&gt; &v, int l, int h)\n{\n    int pivot = v[l];\n    int i = l;\n    for (int j = l + 1; j &lt;= h; j++)\n    {\n        if (v[j] &lt; pivot)\n        {\n            i++;\n            std::swap(v[i], v[j]);\n        }\n    }\n    std::swap(v[i], v[l]);\n    return i;\n}\n\nvoid quickSort(std::vector&lt;int&gt; &v, int l, int h)\n{\n    if (l &lt; h)\n    {\n        const int index = partition(v, l, h);\n        quickSort(v, l, index - 1);\n        quickSort(v, index + 1, h);\n    }\n\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    const int n = v.size();\n    quickSort(v, 0, n - 1);\n    std::cout &lt;&lt; \"Sorted elements with Quick sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\nOutput:\nSorted elements with Quick sort: 1 2 3 4 5 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#merge-sort",
    "href": "C_Plus_Plus/Sorting/sorting.html#merge-sort",
    "title": "Sorting Algorithms",
    "section": "5 Merge sort",
    "text": "5 Merge sort\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nvoid merge(std::vector&lt;int&gt; &v, int l, int h, int mid)\n{\n    int i = l;\n    int j = mid + 1;\n    std::vector&lt;int&gt; temp(v.size() + 1);\n    int k = l;\n    while (i &lt;= mid && j &lt;= h)\n    {\n        if (v[i] &lt; v[j])\n        {\n            temp[k++] = v[i++];\n        }\n        else\n        {\n            temp[k++] = v[j++];\n        }\n    }\n\n    for (; i &lt;= mid; i++)\n    {\n        temp[k++] = v[i];\n    }\n    for (; j &lt;= h; j++)\n    {\n        temp[k++] = v[j];\n    }\n\n    for (int i = l; i &lt;= h; i++)\n    {\n        v[i] = temp[i];\n    }\n}\n\nvoid mergeSort(std::vector&lt;int&gt; &v)\n{\n    int size = v.size();\n    int p = 2;\n    for (; p &lt;= size; p = p * 2)\n    {\n        for (int i = 0; p + i - 1 &lt; size; i = i + p)\n        {\n            int l = i;\n            int h = p + i - 1;\n            int mid = l + (h - l) / 2;\n            merge(v, l, h, mid);\n        }\n    }\n\n    if (p / 2 &lt;= size)\n    {\n        merge(v, 0, size - 1, p / 2 - 1);\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    mergeSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Merge sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\nOutput:\nSorted elements with Merge sort: 1 2 3 4 5 8 \n\n\nNote:merge(v, 0, size - 1, p / 2 - 1);is typically used to handle the remaining unsorted\n elements when the array size is not perfectly divisible by p\n This often happens when the size of the array is odd, but it can also \n happen for any size that doesn't align perfectly with the merging steps.\n l = 0: Start merging from the beginning of the array.\nh = size - 1: The last index of the array (the whole array is considered).\nmid = p / 2 - 1: Marks the midpoint of the last merging step.\n\nExample 1: Odd Size (Unaligned Segments)\n\nSuppose you have an array with size = 5:\nv = {10, 20, 30, 40, 50}\nDuring the merge steps:\nFor p = 2:\nSegments: {10, 20}, {30, 40} → {50} is left over.\nFor p = 4:\nSegments: {10, 20, 30, 40} → {50} is left over.\n\nWhy p / 2 - 1?\np / 2 represents the size of the left segment from the last merging step.\np / 2 - 1 adjusts for zero-based indexing, so it points to the last index of the left segment.\nFor example:\n\nIf p = 4, then:\nLeft segment: [0, 1]\np / 2 - 1 = 4 / 2 - 1 = 1\n\nHow Merge Sort Works (Step by Step)\n\nLet’s see an example for clarity:\nExample: Array v = {5, 3, 8, 4, 2} (size = 5)\n\nInitial Array:\n{5, 3, 8, 4, 2}\n\nStep 1: Break into Segments of p = 2:\nSegments: {5, 3}, {8, 4}, {2}.\nMerge step:\n{3, 5}, {4, 8}, {2}\nStep 2: Break into Segments of p = 4:\nSegments: {3, 5, 4, 8}, {2}.\nMerge step:\n{3, 4, 5, 8}, {2}\nFinal Step: Merge Full Array:\nAt this point, the final merge needs to combine all segments into one sorted array.\nThe merge function call becomes:\nmerge(v, 0, size - 1, p / 2 - 1)\nl = 0: Start merging from the very first index of the array.\nh = size - 1: Merge up to the last index of the array.\nmid = p / 2 - 1: The last index of the left segment (calculated during the merge sort process).\nResult after this merge:\n\n{2, 3, 4, 5, 8}",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#count-sort",
    "href": "C_Plus_Plus/Sorting/sorting.html#count-sort",
    "title": "Sorting Algorithms",
    "section": "6 Count sort",
    "text": "6 Count sort\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nint findMax(std::vector&lt;int&gt; &nums)\n{\n    int max = nums[0];\n    for (int i = 1; i &lt; nums.size(); i++)\n    {\n        if (nums[i] &gt; max)\n        {\n            max = nums[i];\n        }\n    }\n    return max;\n\n}\n\n\nvoid countSort(std::vector&lt;int&gt; &v)\n{\n    std::vector&lt;int&gt; temp(findMax(v), 0);\n    for (const auto x : v)\n    {\n        temp[x]++;\n    }\n    int i = 0;\n    for (int j = 0; j &lt;= temp.size(); j++)\n    {\n        if (temp[j] &gt; 0)\n        {\n            v[i++] = j;\n        }\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    countSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Count Sort: \";\n    for (auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\nOutput:\nSorted elements with Count Sort: 1 2 3 4 5 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Sorting/sorting.html#bucket-sort",
    "href": "C_Plus_Plus/Sorting/sorting.html#bucket-sort",
    "title": "Sorting Algorithms",
    "section": "7 Bucket sort",
    "text": "7 Bucket sort\n#include &lt;iostream&gt;\n#include&lt;vector&gt;\n\nint findMax(std::vector&lt;int&gt; &nums)\n{\n    int max = nums[0];\n    for (int i = 1; i &lt; nums.size(); i++)\n    {\n        if (nums[i] &gt; max)\n        {\n            max = nums[i];\n        }\n    }\n    return max;\n}\n\nint findMin(std::vector&lt;int&gt; &nums)\n{\n    int min = nums[0];\n    for (int i = 1; i &lt; nums.size(); i++)\n    {\n        if (nums[i] &lt; min)\n        {\n            min = nums[i];\n        }\n    }\n    return min;\n}\n\nvoid bucketSort(std::vector&lt;int&gt; &v)\n{\n    const int min = findMin(v);\n    const int max = findMax(v);\n    std::vector&lt;std::vector&lt;int&gt;&gt; buckets(v.size());\n    const int range = max - min + 1; // Range of values\n    // Create buckets\n    int bucketCount = v.size(); // Number of buckets\n    for (auto x : v)\n    {\n        int index = bucketCount * (x - min) / range;\n        if (index == bucketCount)\n            index--; // Handle edge case for max value\n        buckets[index].push_back(x);\n    }\n\n    // Use this logic or below logic\n    // v.clear(); // Clear the vector to merge sorted values\n    // for (auto &bucket : buckets)\n    // {\n    //     std::sort(bucket.begin(), bucket.end()); // Sort each bucket\n    //     v.insert(v.end(), bucket.begin(), bucket.end()); // Merge buckets\n    // }\n\n    // Sort individual buckets\n    for (auto &bucket : buckets)\n    {\n        std::sort(bucket.begin(), bucket.end());\n    }\n    int index = 0; // Index for the original vector\n    for (const auto &bucket : buckets)\n    {\n        for (const auto &element : bucket)\n        {\n            v[index++] = element; // Sequentially update the vector\n        }\n    }\n}\n\nint main()\n{\n    std::vector&lt;int&gt; v{5, 8, 4, 3, 2, 1};\n    bucketSort(v);\n    std::cout &lt;&lt; \"Sorted elements with Bucket Sort: \";\n    for (const auto x : v)\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    return 0;\n}\n\nOutput:\nSorted elements with Bucket Sort: 1 2 3 4 5 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Sorting",
      "Sorting Algorithms"
    ]
  },
  {
    "objectID": "C_Plus_Plus/index.html",
    "href": "C_Plus_Plus/index.html",
    "title": "C Plus Plus",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nHeap in C++\n\n\n\nHeap\n\n\n\nHeap\n\n\n\n\n\nOct 10, 2025\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nQueue in C++\n\n\n\nQueue\n\n\n\nQueue implementation using linked list in C++\n\n\n\n\n\nOct 10, 2025\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nSorting Algorithms\n\n\n\nSorting\n\n\n\nSorting Algorithms(Bubble sort,Insertion sort,Selection sort,Quick sort,Merge sort,Count sort,Bucket sort)\n\n\n\n\n\nNov 22, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nbinary Tree\n\n\n\nTrees\n\n\n\nbinary Tree(creation,tree generation from traversals)\n\n\n\n\n\nNov 16, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nbinary search Tree\n\n\n\nTrees\n\n\n\nbinary search Tree(creation,tree generation from traversals)\n\n\n\n\n\nNov 16, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nBFS\n\n\n\nGraphs\n\n\n\nBreadth First Search\n\n\n\n\n\nNov 16, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nsmart pointers\n\n\n\nSmart-Pointers\n\n\n\nsmart pointers (unique,shared,weak)\n\n\n\n\n\nNov 16, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nLRU cache\n\n\n\nLinked-list\n\n\n\nleast recently used cache\n\n\n\n\n\nNov 14, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\ncircularLinkedList\n\n\n\nLinked-list\n\n\n\nlinkedlist\n\n\n\n\n\nNov 14, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nmergelists\n\n\n\nLinked-list\n\n\n\nlinkedlist merge sorted lists\n\n\n\n\n\nNov 14, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nLinkedlist Basics\n\n\n\nLinked-list\n\n\n\nlinkedlist\n\n\n\n\n\nNov 14, 2024\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nMulti Threading\n\n\n\nMulti Threading\n\n\n\nThreading concepts\n\n\n\n\n\nSep 10, 2023\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nGlimpse of C++\n\n\n\nBasics of c++\n\n\n\nBasics of c++\n\n\n\n\n\nAug 6, 2023\n\n\nYas Mi\n\n\n\n\n\n\n\n\n\n\n\n\nAdvanced C++ study\n\n\n\nAdvanced C++ study\n\n\n\nTemplates,Lambda Functions\n\n\n\n\n\nAug 6, 2023\n\n\nYas Mi\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus"
    ]
  },
  {
    "objectID": "Notes/index.html",
    "href": "Notes/index.html",
    "title": "Notes",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nNotes\n\n\n\nNotes\n\n\n\nNotes\n\n\n\n\n\nAug 26, 2022\n\n\nYasmi\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "{{< fa house >}} Home",
      "Notes"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Auto Glimpses",
    "section": "",
    "text": "Home page Author: Yasmi"
  },
  {
    "objectID": "C_Plus_Plus/Basics/basics_cpp.html",
    "href": "C_Plus_Plus/Basics/basics_cpp.html",
    "title": "Glimpse of C++",
    "section": "",
    "text": "#include&lt;iostream&gt;\nusing namespace std;\n\ntypedef struct \n{\n    const char * name;\n    int ranking;\n    int studentid;\n}studentdataBase;\n\nclass lecture;\n\n class student\n{\n    public:\n    static const studentdataBase studentdataBasec[2];\n\n    friend class lecture;\n};\n\nclass lecture\n    {\n        public:\n        void printstudentData()\n        {\n        cout&lt;&lt;student::studentdataBasec[1].name&lt;&lt;endl;\n        }\n     \n};\n\n\n const studentdataBase student::studentdataBasec[2]=\n{\n    {\n        \"Disha\",\n        1,\n        1234\n    },\n    {\n        \"Isha\",\n        2,\n        4567\n    }\n};\n\nint main()\n{\n    lecture obj;\n    obj.printstudentData();\n\n    return 0;\n}\n\nIn the above program lecture is the friend function of student\nlecture class gets to access the members of class student",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Basics",
      "Glimpse of C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Basics/basics_cpp.html#friend-function",
    "href": "C_Plus_Plus/Basics/basics_cpp.html#friend-function",
    "title": "Glimpse of C++",
    "section": "",
    "text": "#include&lt;iostream&gt;\nusing namespace std;\n\ntypedef struct \n{\n    const char * name;\n    int ranking;\n    int studentid;\n}studentdataBase;\n\nclass lecture;\n\n class student\n{\n    public:\n    static const studentdataBase studentdataBasec[2];\n\n    friend class lecture;\n};\n\nclass lecture\n    {\n        public:\n        void printstudentData()\n        {\n        cout&lt;&lt;student::studentdataBasec[1].name&lt;&lt;endl;\n        }\n     \n};\n\n\n const studentdataBase student::studentdataBasec[2]=\n{\n    {\n        \"Disha\",\n        1,\n        1234\n    },\n    {\n        \"Isha\",\n        2,\n        4567\n    }\n};\n\nint main()\n{\n    lecture obj;\n    obj.printstudentData();\n\n    return 0;\n}\n\nIn the above program lecture is the friend function of student\nlecture class gets to access the members of class student",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Basics",
      "Glimpse of C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Basics/basics_cpp.html#casting-in-c",
    "href": "C_Plus_Plus/Basics/basics_cpp.html#casting-in-c",
    "title": "Glimpse of C++",
    "section": "2 Casting in C++",
    "text": "2 Casting in C++\n\n2.1 const_cast&lt;Type&gt;(variable)\nconst_cast Its used to change the const or volatile qualifiers of pointers or referances . where type should be either pointer, reference or pointer to member type\nint main()\n{\n    int a=5;\n    const int *p=&a;\n    int *b=const_cast&lt;int*&gt;(p)\n    *b=10;\n    cout&lt;&lt;*b&lt;&lt;endl;\n    return 0;\n}\n\nResult=10;\n\n\n\n2.2 static_cast&lt;Type&gt;(variable)\nIts an implicity conversion in c++\nint main()\n{\n    char c='a';\n    int data=static_cast&lt;int&gt;(a);\n    cout&lt;&lt;data&lt;&lt;endl;\n    return 0;\n}\n\nResult=10;\n\n\n\n2.3 reinterpret_cast&lt;Type&gt;(variable)\nIt is used to cast any pointer type to any pointer type\nint main()\n{\n    int a=5;\n    int *iptr=&a;\n    char *cptr=reinterpret_cast&lt;char*&gt;(&iptr);\n    cout&lt;&lt;*cptr&lt;&lt;endl;\n    return 0;\n}\n\n\n2.4 dynamic_cast&lt;Type&gt;(variable)\nIts used for safe downcasting at run time. The dynamic_cast to work atleast one virtual function is necessory in the base class\nclass base\n{\n    public :\n    virtual void print()\n    {\n        cout&lt;&lt;\"hey\"&lt;&lt;endl;\n    }\n};\n\nclass derived : public base\n{\n    public :\n    virtual void print()override\n    {\n        cout&lt;&lt;\"hey derived\"&lt;&lt;endl;\n    }\n};\nint main()\n{\n    derived d_obj;\n    base *b_obj=dynamic_cast&lt;derived*&gt;(&d_obj);\n    b_obj-&gt;print();\n}\n\nResult=hey derived",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Basics",
      "Glimpse of C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Basics/basics_cpp.html#random-notes",
    "href": "C_Plus_Plus/Basics/basics_cpp.html#random-notes",
    "title": "Glimpse of C++",
    "section": "3 Random notes",
    "text": "3 Random notes\nInitialiser with curly braces int x{7}; This doesnt allow narrow conversation int x=7.7; legal authough compiler warn int x{7.7}; illegal it can be used with compound types std::vectorvec{1,2,3,4,5};\nNULL value is 0 in c++\nauto type specifier auto x=6 ; deduces to int auto x{6} same as int x its very useful with complicated types it ignores const, references if we need const or reference we should add it\nwe can use auto in the loop as well\nLambda expression inline function anonymous ideal for short simpler {return 2arg;} [] : put instead of funciton name To invoke it, put() after the body with any arguments //invoke lambda with argument 3 {return 2arg;}(3);\nit can also be stored in a variable of type auto\nauto lam={return 2*arg;} lam(3);\nLambda expression as predicate :\nauto n_even = std::count_if(vector.begin(), vector.end(), [](int n) { return (n % 2 == 0); });\nstd::count_if: This is an STL algorithm that iterates over a given range [first, last) and counts the elements that satisfy a specific condition (predicate). The third parameter of std::count_if is a callable object, which can be a function pointer, a functor, or a lambda function.\n[](int n) { return (n % 2 == 0); }\nThis is an inline anonymous function (lambda). It takes one argument (int n), checks whether n is even (n % 2 == 0), and returns true if it is even, otherwise false\nHow the Lambda is Called: std::count_if will loop through all elements in the range [vector.begin(), vector.end()). For each element elem in the range, std::count_if will internally call the lambda function:  { return (n % 2 == 0); }\npassing the current element elem as the argument n. The lambda function will execute and return a boolean (true or false), indicating whether the current element satisfies the condition (is even). Result Accumulation: If the lambda function returns true, the internal counter of std::count_if is incremented. If it returns false, the counter is not changed. Once the loop completes, std::count_if returns the total count of elements that satisfied the condition (i.e., the number of even numbers in this case).\n//Consider the vector:\nstd::vector&lt;int&gt; vector = {1, 2, 3, 4, 5};\n\n//The lambda function will be invoked as follows:\n\nFor 1: [](int n) { return (n % 2 == 0); } → return (1 % 2 == 0) → false.\nFor 2: [](int n) { return (n % 2 == 0); } → return (2 % 2 == 0) → true.\nFor 3: [](int n) { return (n % 2 == 0); } → return (3 % 2 == 0) → false.\nFor 4: [](int n) { return (n % 2 == 0); } → return (4 % 2 == 0) → true.\nFor 5: [](int n) { return (n % 2 == 0); } → return (5 % 2 == 0) → false.\n//The total count of true results is 2, so n_even = 2.\n\n//lambda local variablaes\nauto add_two=[y=2](int x){return x+y}\nadd_two(2);\nR value reference\nvoid func(int && x)\nfunc(2) //2 is r value int y=2 func(y) error : y is an lvalue you cannot bind an rvalue to l value\nstd::move will cast its argument to r vlaue func(std::move(y))",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Basics",
      "Glimpse of C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Heap/heap.html",
    "href": "C_Plus_Plus/Heap/heap.html",
    "title": "Heap in C++",
    "section": "",
    "text": "Heap is complete binary tree\nif you represent the heap in array there should not be any gap.\nTwo options Every node should have the element to be greater than or equal to it’s descendants - Max heap. Every node should have element to be smaller than or equal to it’s descendant - Min heap.\nWhen deleting you should always delete the root element",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Heap",
      "Heap in C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Heap/heap.html#max-heap-implementation-using-linkedlist",
    "href": "C_Plus_Plus/Heap/heap.html#max-heap-implementation-using-linkedlist",
    "title": "Heap in C++",
    "section": "1 Max Heap implementation using Linkedlist",
    "text": "1 Max Heap implementation using Linkedlist\n#include &lt;iostream&gt;\n#include &lt;new&gt;\n#include &lt;queue&gt;\n\nclass Node\n{\n    public:\n    int data;\n    Node* leftChild;\n    Node* rightChild;\n    Node* parent;\n    Node(int data):data(data), leftChild(nullptr), rightChild(nullptr), parent(nullptr) {};\n};\n\nclass MaxHeap\n{\n    public:\n    Node* head;\n    MaxHeap():head(nullptr){}\n    void insertData(int data)\n    {\n        Node* newNode = new (std::nothrow) Node(data);\n        if (newNode == nullptr) {\n            return;\n        }\n        if (head == nullptr) {\n            head = newNode;\n        } else {\n            std::queue&lt;Node*&gt; q;\n            q.push(head);\n            while (!q.empty()) {\n                Node* cur = q.front(); q.pop();\n\n                if (cur-&gt;leftChild == nullptr) {\n                    cur-&gt;leftChild = newNode;\n                    newNode-&gt;parent = cur;\n                    break;\n                } else {\n                    q.push(cur-&gt;leftChild);\n                }\n\n                if (cur-&gt;rightChild == nullptr) {\n                    cur-&gt;rightChild = newNode;\n                    newNode-&gt;parent = cur;\n                    break;\n                } else {\n                    q.push(cur-&gt;rightChild);\n                }\n            }\n\n            // bubble-up to maintain max-heap (swap data values)\n            Node* child = newNode;\n            while (child-&gt;parent != nullptr && child-&gt;parent-&gt;data &lt; child-&gt;data) {\n                std::swap(child-&gt;parent-&gt;data, child-&gt;data);\n                child = child-&gt;parent;\n            }\n        }  \n    }\n\n    ~MaxHeap(){      \n    }\n    void display() {\n        if (head == nullptr) {\n            std::cout &lt;&lt; \"(empty)\\n\";\n            return;\n        }\n        std::queue&lt;Node*&gt; q;\n        q.push(head);\n        while (!q.empty()) {\n            Node* cur = q.front(); q.pop();\n            std::cout &lt;&lt; cur-&gt;data &lt;&lt; \" \";\n            if (cur-&gt;leftChild) q.push(cur-&gt;leftChild);\n            if (cur-&gt;rightChild) q.push(cur-&gt;rightChild);\n        }\n        std::cout &lt;&lt; std::endl;\n    }    \n};\n \nint main()\n{\n    MaxHeap obj;\n    obj.insertData(30);\n    obj.insertData(15);\n    obj.insertData(20);\n    obj.insertData(10);\n    obj.insertData(12);\n    obj.insertData(6);\n    obj.insertData(5);\n    obj.insertData(40);\n\n    obj.display();\n}\n\nOutput :\n40 30 20 15 12 6 5 10",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Heap",
      "Heap in C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Heap/heap.html#max-heap---insert-delete-heap-sort",
    "href": "C_Plus_Plus/Heap/heap.html#max-heap---insert-delete-heap-sort",
    "title": "Heap in C++",
    "section": "2 Max Heap - Insert, Delete, Heap Sort",
    "text": "2 Max Heap - Insert, Delete, Heap Sort\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n\nvoid insertInHeap(std::vector&lt;int&gt; &A, int size)\n{\n    int i = size;\n    int temp = A[i];\n    while (i &gt; 0 && temp &gt; A[(i-1)/2]) {\n        A[i] = A[(i-1)/2];\n        i = (i-1)/2;\n    }\n    A[i] = temp;\n}\n\nint deleteFromHeap(std::vector&lt;int&gt; &A, int size)\n{\n    int i = 0;\n    int maxVal = A[0];\n    int temp = A[size-1];\n    A[0] = temp;\n    int heapSize = size - 1;\n    int j = 2*i + 1;\n\n    while (j &lt; heapSize) {\n        if (j + 1 &lt; heapSize && A[j+1] &gt; A[j]) {\n            j = j + 1;\n        }\n        if (A[i] &lt; A[j]) {\n            std::swap(A[i], A[j]);\n            i = j;\n            j = 2*i + 1;\n        } else {\n            break;\n        }\n    }\n    return maxVal;\n}\n\nvoid heapSort(std::vector&lt;int&gt; &A, int size)\n{\n    int i = 0;\n    int temp = A[size-1];\n    std::swap(A[0], A[size-1]);\n    int heapSize = size - 1;\n    int j = 2*i + 1;\n\n    while ( j &lt; heapSize ) {\n        if ( j + 1 &lt; heapSize && A[j+1] &gt; A[j]) {\n            j = j + 1;\n        }\n        if (A[i] &lt; A[j]) {\n            std::swap(A[i], A[j]);\n            i = j;\n            j = 2*i + 1;\n        } else {\n            break;\n        }\n    }\n   \n}\n\nint main()\n{\n    std::vector&lt;int&gt; H{14,15,5,20,30,8,40};\n    int size = H.size();\n    for (int i = 1; i &lt; size; i++) {\n        insertInHeap(H,i);\n    } \n\n    int newValue = 50;                 \n    H.push_back(newValue);            \n    insertInHeap(H, static_cast&lt;int&gt;(H.size() - 1)); \n    size = static_cast&lt;int&gt;(H.size());\n\n    std::cout &lt;&lt; \"Heap before delete: \";\n    for (int i = 0; i &lt; size; i++) {\n        std::cout &lt;&lt; H[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    int deletedValue = deleteFromHeap(H, size); \n    H.pop_back();                                \n    size = static_cast&lt;int&gt;(H.size());         \n    std::cout &lt;&lt; \"Deleted max: \" &lt;&lt; deletedValue &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Heap after delete: \";\n    for (int i = 0; i &lt; size; i++) {\n        std::cout &lt;&lt; H[i] &lt;&lt; \" \";\n    }\n\n    std::cout &lt;&lt; std::endl;\n    for (int i = size; i &gt; 1; i--) {\n        heapSort(H,i);\n    }\n    std::cout &lt;&lt; \"After heapsort: \";\n    for (int i = 0; i &lt; size; i++) {\n        std::cout &lt;&lt; H[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl; \n\n    return 0;\n}\noutput:\nHeap before delete: 50 40 30 20 15 5 8 14 \nDeleted max: 50\nHeap after delete: 40 20 30 14 15 5 8\nAfter heapsort: 5 8 14 15 20 30 40\n\n2.0.1 Pictortial representation of insert and Delete\n\n\n\nmaxHeapInsertAndDelete",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Heap",
      "Heap in C++"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binaryTree.html",
    "href": "C_Plus_Plus/Trees/binaryTree.html",
    "title": "binary Tree",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;queue&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass binaryTree\n{\npublic:\n    Node *root;\n\n    binaryTree(): root(nullptr)\n    {\n    }\n\n\n    void createBinaryTree(int data)\n    {\n        Node *newNode = new Node(data);\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        q.push(root);\n        while (!q.empty())\n        {\n            Node *temp = q.front();\n            q.pop();\n            if (temp-&gt;leftChild == nullptr)\n            {\n                temp-&gt;leftChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;leftChild);\n            }\n            if (temp-&gt;rightChild == nullptr)\n            {\n                temp-&gt;rightChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;rightChild);\n            }\n\n        }\n\n    }\n\n    int count(Node *root)\n    {\n        if (root == nullptr)\n            return 0;\n        const int x = count(root-&gt;leftChild);\n        const int y = count(root-&gt;rightChild);\n        return x + y + 1;\n    }\n\n    void display() const\n    {\n        if (root == nullptr)\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n        else\n        {\n            std::queue&lt;Node *&gt; q;\n            q.push(root);\n            while (!q.empty())\n            {\n                Node *current = q.front();\n                q.pop();\n                std::cout &lt;&lt; current-&gt;data &lt;&lt; \" \";\n                if (current-&gt;leftChild != nullptr)\n                    q.push(current-&gt;leftChild);\n                if (current-&gt;rightChild != nullptr)\n                    q.push(current-&gt;rightChild);\n            }\n        }\n    }\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    ~binaryTree()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    binaryTree obj;\n    obj.createBinaryTree(5);\n    obj.createBinaryTree(6);\n    obj.createBinaryTree(4);\n    obj.createBinaryTree(8);\n    obj.createBinaryTree(9);\n    std::cout &lt;&lt; \"Binary tree elements\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n    const auto count = obj.count(obj.root);\n    std::cout &lt;&lt; \"No of nodes: \" &lt;&lt; count &lt;&lt; std::endl;\n    return 0;\n}\nOutput :\nBinary tree elements\n5 6 4 8 9 \nNo of nodes: 5",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binaryTree.html#binary-tree-creation",
    "href": "C_Plus_Plus/Trees/binaryTree.html#binary-tree-creation",
    "title": "binary Tree",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;queue&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass binaryTree\n{\npublic:\n    Node *root;\n\n    binaryTree(): root(nullptr)\n    {\n    }\n\n\n    void createBinaryTree(int data)\n    {\n        Node *newNode = new Node(data);\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        q.push(root);\n        while (!q.empty())\n        {\n            Node *temp = q.front();\n            q.pop();\n            if (temp-&gt;leftChild == nullptr)\n            {\n                temp-&gt;leftChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;leftChild);\n            }\n            if (temp-&gt;rightChild == nullptr)\n            {\n                temp-&gt;rightChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;rightChild);\n            }\n\n        }\n\n    }\n\n    int count(Node *root)\n    {\n        if (root == nullptr)\n            return 0;\n        const int x = count(root-&gt;leftChild);\n        const int y = count(root-&gt;rightChild);\n        return x + y + 1;\n    }\n\n    void display() const\n    {\n        if (root == nullptr)\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n        else\n        {\n            std::queue&lt;Node *&gt; q;\n            q.push(root);\n            while (!q.empty())\n            {\n                Node *current = q.front();\n                q.pop();\n                std::cout &lt;&lt; current-&gt;data &lt;&lt; \" \";\n                if (current-&gt;leftChild != nullptr)\n                    q.push(current-&gt;leftChild);\n                if (current-&gt;rightChild != nullptr)\n                    q.push(current-&gt;rightChild);\n            }\n        }\n    }\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    ~binaryTree()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    binaryTree obj;\n    obj.createBinaryTree(5);\n    obj.createBinaryTree(6);\n    obj.createBinaryTree(4);\n    obj.createBinaryTree(8);\n    obj.createBinaryTree(9);\n    std::cout &lt;&lt; \"Binary tree elements\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n    const auto count = obj.count(obj.root);\n    std::cout &lt;&lt; \"No of nodes: \" &lt;&lt; count &lt;&lt; std::endl;\n    return 0;\n}\nOutput :\nBinary tree elements\n5 6 4 8 9 \nNo of nodes: 5",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binaryTree.html#binary-tree-traversalstree-generation-height-calculation",
    "href": "C_Plus_Plus/Trees/binaryTree.html#binary-tree-traversalstree-generation-height-calculation",
    "title": "binary Tree",
    "section": "2 Binary tree traversals,Tree generation, Height calculation",
    "text": "2 Binary tree traversals,Tree generation, Height calculation\n#include &lt;iostream&gt;\n#include&lt;queue&gt;\n#include &lt;cmath&gt;\n#include &lt;iomanip&gt; // For std::setw\n\n/*Binary tree generation from in-order and pre-order traversals*/\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data): data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n\n};\n\nclass binaryTree\n{\npublic:\n    Node *root;\n\n    binaryTree(): root(nullptr)\n    {\n    }\n\n\n    void createBinaryTree(int data)\n    {\n        Node *newNode = new Node(data);\n        std::queue&lt;Node *&gt; q;\n        if (root == nullptr)\n        {\n            root = newNode;\n            return;\n        }\n        q.push(root);\n        while (!q.empty())\n        {\n            Node *temp = q.front();\n            q.pop();\n            if (temp-&gt;leftChild == nullptr)\n            {\n                temp-&gt;leftChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;leftChild);\n            }\n            if (temp-&gt;rightChild == nullptr)\n            {\n                temp-&gt;rightChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;rightChild);\n            }\n\n        }\n\n    }\n\n\n    void display() const\n    {\n        std::cout &lt;&lt; \"tree elements\" &lt;&lt; std::endl;\n        if (root == nullptr)\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n        else\n        {\n            std::queue&lt;Node *&gt; q;\n            q.push(root);\n            while (!q.empty())\n            {\n                Node *current = q.front();\n                q.pop();\n                std::cout &lt;&lt; current-&gt;data &lt;&lt; \" \";\n                if (current-&gt;leftChild != nullptr)\n                    q.push(current-&gt;leftChild);\n                if (current-&gt;rightChild != nullptr)\n                    q.push(current-&gt;rightChild);\n            }\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n\n    void deleteTree(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        // Recursively delete left and right children\n        deleteTree(node-&gt;leftChild);\n        deleteTree(node-&gt;rightChild);\n\n        // Delete the current node\n        delete node;\n    }\n\n    std::vector&lt;int&gt; preOrder(Node *node)\n    {\n        std::vector&lt;int&gt; preOrderStack; // Use a non-static local variable\n        preOrderHelper(node, preOrderStack); // Helper function handles recursion\n        return preOrderStack; // Return the result\n    }\n\n    void preOrderHelper(Node *node, std::vector&lt;int&gt; &preOrderStack)\n    {\n        if (node == nullptr)\n            return;\n\n        preOrderStack.push_back(node-&gt;data);\n\n        // Recurse for left and right subtrees\n        preOrderHelper(node-&gt;leftChild, preOrderStack);\n        preOrderHelper(node-&gt;rightChild, preOrderStack);\n    }\n\n    std::vector&lt;int&gt; inOrder(Node *node)\n    {\n        std::vector&lt;int&gt; inOrderStack; // Use a non-static local variable\n        inOrderHelper(node, inOrderStack); // Helper function handles recursion\n        return inOrderStack; // Return the result\n    }\n\n    void inOrderHelper(Node *node, std::vector&lt;int&gt; &inOrderStack)\n    {\n        if (node == nullptr)\n            return;\n        inOrderHelper(node-&gt;leftChild, inOrderStack);\n        inOrderStack.push_back(node-&gt;data);\n        inOrderHelper(node-&gt;rightChild, inOrderStack);\n    }\n\n    int findInorder(std::vector&lt;int&gt; inOrder, Node *node, int start, int end)\n    {\n        for (int i = start; i &lt;= end; i++)\n        {\n            if (inOrder[i] == node-&gt;data)\n                return i;\n        }\n        return -1;\n    }\n\n    Node *treeGeneration(std::vector&lt;int&gt; &preOrder, std::vector&lt;int&gt; &inOrder, int start, int end)\n    {\n        static int i = 0;\n        if (start &gt; end)\n            // Base case: no subtree\n            return nullptr;\n\n        auto node = new Node(preOrder[i++]);\n        // If the subtree has only one node\n        if (start == end)\n            return node;\n        int index = findInorder(inOrder, node, start, end);\n        node-&gt;leftChild = treeGeneration(preOrder, inOrder, start, index - 1);\n        node-&gt;rightChild = treeGeneration(preOrder, inOrder, index + 1, end);\n        // Return the root node of the subtree\n        return node;\n    }\n\n\n    int calculateHeight(Node *root)\n    {\n        if (!root)\n            return 0;\n        int x = calculateHeight(root-&gt;leftChild);\n        int y = calculateHeight(root-&gt;rightChild);\n        if (x &gt; y)\n            return x + 1;\n        else\n            return y + 1;\n    }\n\n    // Function to print the binary tree\n    void printTree(Node *root)\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Empty Tree\" &lt;&lt; std::endl;\n            return;\n        }\n\n        int height = calculateHeight(root); // Calculate the tree's height\n        int maxWidth = pow(2, height) - 1; // Maximum number of nodes in the last level\n        int levelSpacing = 3; // Base spacing between nodes\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        for (int level = 0; level &lt; height; ++level)\n        {\n            int levelSize = q.size();\n            int spacesBefore = (maxWidth / pow(2, level + 1)) * levelSpacing; // Spaces before first node\n            int spacesBetween = spacesBefore * 2; // Spaces between nodes\n\n            // Print leading spaces for the level\n            std::cout &lt;&lt; std::setw(spacesBefore);\n\n            for (int i = 0; i &lt; levelSize; ++i)\n            {\n                Node *current = q.front();\n                q.pop();\n\n                if (current)\n                {\n                    std::cout &lt;&lt; current-&gt;data;\n                    q.push(current-&gt;leftChild);\n                    q.push(current-&gt;rightChild);\n                }\n                else\n                {\n                    std::cout &lt;&lt; \" \"; // Placeholder for missing nodes\n                    q.push(nullptr);\n                    q.push(nullptr);\n                }\n\n                // Print spaces between nodes\n                std::cout &lt;&lt; std::setw(spacesBetween) &lt;&lt; \" \";\n            }\n\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    ~binaryTree()\n    {\n        deleteTree(root);\n    }\n};\n\nint main()\n{\n    binaryTree obj;\n    obj.createBinaryTree(5);\n    obj.createBinaryTree(6);\n    obj.createBinaryTree(4);\n    obj.createBinaryTree(8);\n    obj.createBinaryTree(9);\n    obj.createBinaryTree(2);\n    obj.createBinaryTree(3);\n    obj.display();\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"Binary Tree original\" &lt;&lt; std::endl;\n    obj.printTree(obj.root);\n    std::cout &lt;&lt; std::endl;\n\n    auto pre = obj.preOrder(obj.root);\n    std::cout &lt;&lt; \"preOrder List\" &lt;&lt; std::endl;\n    for (auto i : pre)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n\n    auto inOrder = obj.inOrder(obj.root);\n    std::cout &lt;&lt; \"inOrder List\" &lt;&lt; std::endl;\n    for (auto i : inOrder)\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    std::cout &lt;&lt; std::endl;\n\n    Node *node = obj.treeGeneration(pre, inOrder, 0, pre.size() - 1);\n    std::cout &lt;&lt; \"Binary Tree generated\" &lt;&lt; std::endl;\n    obj.printTree(node);\n    return 0;\n}\ntree elements\n5 6 4 8 9 2 3 \n\nBinary Tree original\n         5                    \n    6          4          \n 8    9    2    3    \n\npreOrder List\n5 6 8 9 4 2 3 \n\ninOrder List\n8 6 9 5 2 4 3 \n\nBinary Tree generated\n         5                    \n    6          4          \n 8    9    2    3",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Trees/binaryTree.html#delete-node-from-binary-tree",
    "href": "C_Plus_Plus/Trees/binaryTree.html#delete-node-from-binary-tree",
    "title": "binary Tree",
    "section": "3 Delete Node from Binary tree",
    "text": "3 Delete Node from Binary tree\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *leftChild;\n    Node *rightChild;\n\n    explicit Node(int data) : data(data), leftChild(nullptr), rightChild(nullptr)\n    {\n    }\n};\n\nclass binaryTree\n{\npublic:\n    Node *root;\n\n    binaryTree() : root(nullptr)\n    {\n    }\n\n    // Function to insert a node in a binary tree (level-order insertion)\n    void insert(int data)\n    {\n        Node *newNode = new Node(data);\n\n        if (!root)\n        {\n            root = newNode;\n            return;\n        }\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            Node *temp = q.front();\n            q.pop();\n\n            if (!temp-&gt;leftChild)\n            {\n                temp-&gt;leftChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;leftChild);\n            }\n\n            if (!temp-&gt;rightChild)\n            {\n                temp-&gt;rightChild = newNode;\n                return;\n            }\n            else\n            {\n                q.push(temp-&gt;rightChild);\n            }\n        }\n    }\n\n    // Function to perform level-order traversal\n    void levelOrder()\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Tree is empty.\" &lt;&lt; std::endl;\n            return;\n        }\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            Node *temp = q.front();\n            q.pop();\n\n            std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n\n            if (temp-&gt;leftChild)\n            {\n                q.push(temp-&gt;leftChild);\n            }\n\n            if (temp-&gt;rightChild)\n            {\n                q.push(temp-&gt;rightChild);\n            }\n        }\n\n        std::cout &lt;&lt; std::endl;\n    }\n\n    // Function to find the deepest node\n    Node *findDeepestNode()\n    {\n        if (!root)\n            return nullptr;\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n        Node *temp = nullptr;\n\n        while (!q.empty())\n        {\n            temp = q.front();\n            q.pop();\n\n            if (temp-&gt;leftChild)\n            {\n                q.push(temp-&gt;leftChild);\n            }\n\n            if (temp-&gt;rightChild)\n            {\n                q.push(temp-&gt;rightChild);\n            }\n        }\n\n        return temp; // The last node processed is the deepest node\n    }\n\n    // Function to delete the deepest node\n    void deleteDeepestNode(Node *deepest)\n    {\n        if (!root || !deepest)\n            return;\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n\n        while (!q.empty())\n        {\n            Node *temp = q.front();\n            q.pop();\n\n            if (temp == deepest)\n            {\n                delete deepest;\n                return;\n            }\n\n            if (temp-&gt;leftChild)\n            {\n                if (temp-&gt;leftChild == deepest)\n                {\n                    delete temp-&gt;leftChild;\n                    temp-&gt;leftChild = nullptr;\n                    return;\n                }\n                else\n                {\n                    q.push(temp-&gt;leftChild);\n                }\n            }\n\n            if (temp-&gt;rightChild)\n            {\n                if (temp-&gt;rightChild == deepest)\n                {\n                    delete temp-&gt;rightChild;\n                    temp-&gt;rightChild = nullptr;\n                    return;\n                }\n                else\n                {\n                    q.push(temp-&gt;rightChild);\n                }\n            }\n        }\n    }\n\n    // Function to delete a node with a given value\n    void deleteNode(int value)\n    {\n        if (!root)\n        {\n            std::cout &lt;&lt; \"Tree is empty.\" &lt;&lt; std::endl;\n            return;\n        }\n\n        if (root-&gt;data == value && !root-&gt;leftChild && !root-&gt;rightChild)\n        {\n            // If the tree only has one node and it's the one to delete\n            delete root;\n            root = nullptr;\n            return;\n        }\n\n        std::queue&lt;Node *&gt; q;\n        q.push(root);\n        Node *nodeToDelete = nullptr;\n        Node *temp = nullptr;\n\n        // Find the node to delete\n        while (!q.empty())\n        {\n            temp = q.front();\n            q.pop();\n\n            if (temp-&gt;data == value)\n            {\n                nodeToDelete = temp;\n            }\n\n            if (temp-&gt;leftChild)\n            {\n                q.push(temp-&gt;leftChild);\n            }\n\n            if (temp-&gt;rightChild)\n            {\n                q.push(temp-&gt;rightChild);\n            }\n        }\n\n        if (!nodeToDelete)\n        {\n            std::cout &lt;&lt; \"Node not found in the tree.\" &lt;&lt; std::endl;\n            return;\n        }\n\n        // Find the deepest node\n        Node *deepest = findDeepestNode();\n\n        // Replace nodeToDelete's data with deepest node's data\n        if (deepest)\n        {\n            nodeToDelete-&gt;data = deepest-&gt;data;\n\n            // Delete the deepest node\n            deleteDeepestNode(deepest);\n        }\n    }\n};\n\nint main()\n{\n    binaryTree tree;\n\n    // Insert nodes into the tree\n    tree.insert(1);\n    tree.insert(2);\n    tree.insert(3);\n    tree.insert(4);\n    tree.insert(5);\n    tree.insert(6);\n    tree.insert(7);\n\n    std::cout &lt;&lt; \"Level-order traversal before deletion:\" &lt;&lt; std::endl;\n    tree.levelOrder();\n\n    // Delete a node\n    tree.deleteNode(3);\n\n    std::cout &lt;&lt; \"Level-order traversal after deleting node 3:\" &lt;&lt; std::endl;\n    tree.levelOrder();\n\n    return 0;\n}\nLevel-order traversal before deletion:\n1 2 3 4 5 6 7 \nLevel-order traversal after deleting node 3:\n1 2 7 4 5 6",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Trees",
      "binary Tree"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/LRU_Cache.html",
    "href": "C_Plus_Plus/Linked-list/LRU_Cache.html",
    "title": "LRU cache",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;map&gt;\n\n/*LRU Cache :least recently used value/node should be removed  in case the cache is full\n* most recently used value/node should be always at the head for easy access*/\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n    Node *prev;\n    int key;\n\n    Node(int key, int data): key(key), data(data), next(nullptr), prev(nullptr)\n    {\n    }\n\n};\n\nclass lruCache\n{\npublic:\n    Node *head;\n    Node *tail;\n    std::unordered_map&lt;int, Node *&gt; cache;\n    int capacity;\n\n    explicit lruCache(int capacity): capacity(capacity), head(nullptr), tail(nullptr)\n    {\n    }\n\n    void insert(Node *node)\n    {\n        if (head == nullptr)\n        {\n            head = node;\n            tail = node;\n        }\n        else\n        {\n            node-&gt;next = head;\n            head-&gt;prev = node;\n            head = node;\n        }\n        node-&gt;prev = nullptr;\n    }\n\n    void remove(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        if (head == node)\n        {\n            head = head-&gt;next;\n            if (head != nullptr)\n                head-&gt;prev = nullptr;\n        }\n        else if (tail == node)\n        {\n            tail = tail-&gt;prev;\n            if (tail != nullptr)\n                tail-&gt;next = nullptr;\n        }\n        else\n        {\n            if (node-&gt;prev != nullptr)\n                node-&gt;prev-&gt;next = node-&gt;next;\n            if (node-&gt;next != nullptr)\n                node-&gt;next-&gt;prev = node-&gt;prev;\n        }\n    }\n\n    Node *get(int key)\n    {\n        if (cache.find(key) == cache.end())\n            return nullptr;\n        auto node = cache[key];\n        remove(node);\n        insert(node);\n        return node;\n    }\n\n    void put(int key, int data)\n    {\n        if (cache.find(key) != cache.end())\n        {\n            auto node = cache[key];\n            node-&gt;data = data;\n            remove(node);\n            insert(node);\n        }\n        else\n        {\n            if (cache.size() == capacity)\n            {\n                cache.erase(tail-&gt;key);\n                remove(tail);\n            }\n            Node *newNode = new Node(key, data);\n            cache.insert({key, newNode});\n            insert(newNode);\n        }\n\n    }\n\n    void display() const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"Cache is empty\" &lt;&lt; std::endl;\n            return;\n        }\n\n        const Node *temp = head;\n        while (temp != nullptr)\n        {\n            std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n            temp = temp-&gt;next;\n        }\n        std::cout &lt;&lt; std::endl;\n\n    }\n\n    ~lruCache()\n    {\n        while (head != nullptr)\n        {\n            Node *nextNode = head-&gt;next;\n            delete head;\n            head = nextNode;\n        }\n        cache.clear();\n    }\n};\n\nint main()\n{\n    lruCache obj(2);\n    obj.put(1, 2);\n    obj.put(3, 4);\n    std::cout &lt;&lt; \"lruCache after put:\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; \"lruCache after get:\" &lt;&lt; std::endl;\n    obj.get(1);\n    obj.display();\n    return 0;\n}\nOutput :\nlruCache after put:\n4 2 \nlruCache after get:\n2 4",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "LRU cache"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/LRU_Cache.html#lru-cache",
    "href": "C_Plus_Plus/Linked-list/LRU_Cache.html#lru-cache",
    "title": "LRU cache",
    "section": "",
    "text": "#include &lt;iostream&gt;\n#include&lt;map&gt;\n\n/*LRU Cache :least recently used value/node should be removed  in case the cache is full\n* most recently used value/node should be always at the head for easy access*/\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n    Node *prev;\n    int key;\n\n    Node(int key, int data): key(key), data(data), next(nullptr), prev(nullptr)\n    {\n    }\n\n};\n\nclass lruCache\n{\npublic:\n    Node *head;\n    Node *tail;\n    std::unordered_map&lt;int, Node *&gt; cache;\n    int capacity;\n\n    explicit lruCache(int capacity): capacity(capacity), head(nullptr), tail(nullptr)\n    {\n    }\n\n    void insert(Node *node)\n    {\n        if (head == nullptr)\n        {\n            head = node;\n            tail = node;\n        }\n        else\n        {\n            node-&gt;next = head;\n            head-&gt;prev = node;\n            head = node;\n        }\n        node-&gt;prev = nullptr;\n    }\n\n    void remove(Node *node)\n    {\n        if (node == nullptr)\n            return;\n\n        if (head == node)\n        {\n            head = head-&gt;next;\n            if (head != nullptr)\n                head-&gt;prev = nullptr;\n        }\n        else if (tail == node)\n        {\n            tail = tail-&gt;prev;\n            if (tail != nullptr)\n                tail-&gt;next = nullptr;\n        }\n        else\n        {\n            if (node-&gt;prev != nullptr)\n                node-&gt;prev-&gt;next = node-&gt;next;\n            if (node-&gt;next != nullptr)\n                node-&gt;next-&gt;prev = node-&gt;prev;\n        }\n    }\n\n    Node *get(int key)\n    {\n        if (cache.find(key) == cache.end())\n            return nullptr;\n        auto node = cache[key];\n        remove(node);\n        insert(node);\n        return node;\n    }\n\n    void put(int key, int data)\n    {\n        if (cache.find(key) != cache.end())\n        {\n            auto node = cache[key];\n            node-&gt;data = data;\n            remove(node);\n            insert(node);\n        }\n        else\n        {\n            if (cache.size() == capacity)\n            {\n                cache.erase(tail-&gt;key);\n                remove(tail);\n            }\n            Node *newNode = new Node(key, data);\n            cache.insert({key, newNode});\n            insert(newNode);\n        }\n\n    }\n\n    void display() const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"Cache is empty\" &lt;&lt; std::endl;\n            return;\n        }\n\n        const Node *temp = head;\n        while (temp != nullptr)\n        {\n            std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n            temp = temp-&gt;next;\n        }\n        std::cout &lt;&lt; std::endl;\n\n    }\n\n    ~lruCache()\n    {\n        while (head != nullptr)\n        {\n            Node *nextNode = head-&gt;next;\n            delete head;\n            head = nextNode;\n        }\n        cache.clear();\n    }\n};\n\nint main()\n{\n    lruCache obj(2);\n    obj.put(1, 2);\n    obj.put(3, 4);\n    std::cout &lt;&lt; \"lruCache after put:\" &lt;&lt; std::endl;\n    obj.display();\n    std::cout &lt;&lt; \"lruCache after get:\" &lt;&lt; std::endl;\n    obj.get(1);\n    obj.display();\n    return 0;\n}\nOutput :\nlruCache after put:\n4 2 \nlruCache after get:\n2 4",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "LRU cache"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/mergeLists.html",
    "href": "C_Plus_Plus/Linked-list/mergeLists.html",
    "title": "mergelists",
    "section": "",
    "text": "// Created by Yasmi on 13/11/24.\n\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n\n            temp-&gt;next = new Node(data);\n        }\n    }\n\n    Node *mergeLists(Node *&list1, Node *&list2)\n    {\n        if (list1 == nullptr)\n            return list2;\n        if (list2 == nullptr)\n            return list1;\n\n        Node *last = nullptr;\n        Node *third = nullptr;\n        while (list1 != nullptr && list2 != nullptr)\n        {\n            if (list1-&gt;data &lt; list2-&gt;data)\n            {\n                if (third == nullptr)\n                {\n                    last = third = list1;\n                }\n                else\n                {\n                    last-&gt;next = list1;\n                    last = last-&gt;next;\n                }\n                list1 = list1-&gt;next;\n\n            }\n            else\n            {\n                if (third == nullptr)\n                {\n                    last = third = list2;\n                }\n                else\n                {\n                    last-&gt;next = list2;\n                    last = last-&gt;next;\n                }\n                list2 = list2-&gt;next;\n            }\n        }\n        if (list1 != nullptr)\n        {\n            last-&gt;next = list1;\n            list1 = nullptr;\n        }\n        else if (list2 != nullptr)\n        {\n            last-&gt;next = list2;\n            list2 = nullptr;\n        }\n        return third;\n    }\n\n\n    void display(Node *head) const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n\n    }\n\n    ~singleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp; // Frees the current node\n                temp = nextNode; // Moves to the next node\n            }\n        }\n    }\n};\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtTail(1);\n    obj.insertAtTail(3);\n    obj.insertAtTail(5);\n    std::cout &lt;&lt; \"list1\" &lt;&lt; std::endl;\n    obj.display(obj.head);\n\n    singleLinkedList obj1;\n    obj1.insertAtTail(2);\n    obj1.insertAtTail(4);\n    obj1.insertAtTail(6);\n    obj1.insertAtTail(8);\n    std::cout &lt;&lt; \"list2\" &lt;&lt; std::endl;\n    obj1.display(obj1.head);\n\n    singleLinkedList obj2;\n    Node *node = obj2.mergeLists(obj.head, obj1.head);\n    std::cout &lt;&lt; \"merged list\" &lt;&lt; std::endl;\n    obj2.display(node);\n    return 0;\n}\nOutput :\nlist1\n1 3 5 \nlist2\n2 4 6 8 \nmerged list\n1 2 3 4 5 6 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "mergelists"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Linked-list/mergeLists.html#merge-list",
    "href": "C_Plus_Plus/Linked-list/mergeLists.html#merge-list",
    "title": "mergelists",
    "section": "",
    "text": "// Created by Yasmi on 13/11/24.\n\n#include &lt;iostream&gt;\n\nclass Node\n{\npublic:\n    int data;\n    Node *next;\n\n    explicit Node(int data): data(data), next(nullptr)\n    {\n    }\n\n    Node(int data, Node *next): data(data), next(nullptr)\n    {\n    }\n};\n\nclass singleLinkedList\n{\npublic:\n    Node *head;\n\n    singleLinkedList(): head(nullptr)\n    {\n    }\n\n    void insertAtTail(int data)\n    {\n        if (head == nullptr)\n        {\n            head = new Node(data);\n        }\n        else\n        {\n            Node *temp = head;\n            while (temp-&gt;next != nullptr)\n            {\n                temp = temp-&gt;next;\n            }\n\n            temp-&gt;next = new Node(data);\n        }\n    }\n\n    Node *mergeLists(Node *&list1, Node *&list2)\n    {\n        if (list1 == nullptr)\n            return list2;\n        if (list2 == nullptr)\n            return list1;\n\n        Node *last = nullptr;\n        Node *third = nullptr;\n        while (list1 != nullptr && list2 != nullptr)\n        {\n            if (list1-&gt;data &lt; list2-&gt;data)\n            {\n                if (third == nullptr)\n                {\n                    last = third = list1;\n                }\n                else\n                {\n                    last-&gt;next = list1;\n                    last = last-&gt;next;\n                }\n                list1 = list1-&gt;next;\n\n            }\n            else\n            {\n                if (third == nullptr)\n                {\n                    last = third = list2;\n                }\n                else\n                {\n                    last-&gt;next = list2;\n                    last = last-&gt;next;\n                }\n                list2 = list2-&gt;next;\n            }\n        }\n        if (list1 != nullptr)\n        {\n            last-&gt;next = list1;\n            list1 = nullptr;\n        }\n        else if (list2 != nullptr)\n        {\n            last-&gt;next = list2;\n            list2 = nullptr;\n        }\n        return third;\n    }\n\n\n    void display(Node *head) const\n    {\n        if (head == nullptr)\n        {\n            std::cout &lt;&lt; \"List is empty\" &lt;&lt; std::endl;\n        }\n        else\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                std::cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n                temp = temp-&gt;next;\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n\n    }\n\n    ~singleLinkedList()\n    {\n        if (head != nullptr)\n        {\n            const Node *temp = head;\n            while (temp != nullptr)\n            {\n                const Node *nextNode = temp-&gt;next;\n                delete temp; // Frees the current node\n                temp = nextNode; // Moves to the next node\n            }\n        }\n    }\n};\n\nint main()\n{\n    singleLinkedList obj;\n    obj.insertAtTail(1);\n    obj.insertAtTail(3);\n    obj.insertAtTail(5);\n    std::cout &lt;&lt; \"list1\" &lt;&lt; std::endl;\n    obj.display(obj.head);\n\n    singleLinkedList obj1;\n    obj1.insertAtTail(2);\n    obj1.insertAtTail(4);\n    obj1.insertAtTail(6);\n    obj1.insertAtTail(8);\n    std::cout &lt;&lt; \"list2\" &lt;&lt; std::endl;\n    obj1.display(obj1.head);\n\n    singleLinkedList obj2;\n    Node *node = obj2.mergeLists(obj.head, obj1.head);\n    std::cout &lt;&lt; \"merged list\" &lt;&lt; std::endl;\n    obj2.display(node);\n    return 0;\n}\nOutput :\nlist1\n1 3 5 \nlist2\n2 4 6 8 \nmerged list\n1 2 3 4 5 6 8",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Linked List",
      "mergelists"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Advanced/multi_threading.html",
    "href": "C_Plus_Plus/Advanced/multi_threading.html",
    "title": "Multi Threading",
    "section": "",
    "text": "Purpose of Mutex : A mutex is used to coordinate mutually exclusive access to resources by multiple threads of execution. The mutex class is used to protect shared data from corruption due to simultaneous access by multiple threads.\nPurpose of producer consumer idiom : To facilitate threads that produce data and threads that consume data using a single common and coordinated container In the producer-consumer idiom one thread produces data and another consumes data, using one container to hold the data.\nWhat is the difference between sleep_for and sleep_until? sleep_for will sleep for a specified interval; sleep_until will sleep until a specified point in time. Both functions are in the this_thread namespace and both use objects from the chrono library for their arguments.\nHow does async return values from a thread? async returns values in a future object async uses the promise and future paradigm to return values to the caller.\nthread::join() method use case? The join() method blocks execution of the caller until the thread completes.\nWhat types qualify for use with std::atomic? std::atomic requires a trivial type. All primitive types are trivial, including bool, int, float, and double. std::atomic works with any trivial type. Trivial types include primitives such as bool, int, float, and double, as well as any class that uses the default constructor, copy constructor, copy assignment, and destructor.\n\n\n\nThread is useful for parallelism\nThread shall be created by below methods\n\nFunction pointer\nLambda function\nFunctor\nNon static member function\nStatic member function\n\nJoin helps to include the thread to main thread here the main thread is main function , if join is not present the main thread continue to execute before waiting for the t1 thread to finish .\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid countFunction()\n{\n    for(int i=0;i&lt;10;i++)\n    {\n        counter++;\n        cout&lt;&lt;\"count function\"&lt;&lt;endl;\n    }\n}\n\n\nint main()\n{\ncout&lt;&lt;\"Main thread called\"&lt;&lt;endl;\n//Thread creation using function pointer\nthread t1(countFunction);\nt1.join();\ncout&lt;&lt;\"Main thread continued\"&lt;&lt;endl;\n}\nThread creation\nclass fClass\n{\n    public:\n    void operator()(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n\n    void printf(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n\n\n    static void printSt(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n};\n\nvoid print(int x)\n{\ncout&lt;&lt;x&lt;&lt;endl;\n}\nint main()\n{\n    //Thread creation using function pointer\n    thread t1(print,10);\n    t1.join;\n   //Thread creation using lambda\n   thread t3(([](int x){cout&lt;&lt;x&lt;&lt;endl;}),10);\n    t3.join();\n    //Thread creation using functor \n    thread t3(fClass(),10);\n    t3.join();\n    //Thread creation using non static member function \n    fClass obj;\n    thread t4(&fClass::printf,&obj,10);\n    t4.join();\n    //Thread creation using static member\n    thread t5(fClass::printSt,10);\n}\n\n\n\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.join();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n}\nResult : main  thread print - (waiting for 5sec) it prints after join  main continued \nWhen the thread created it starts running the thread and the control comes back to the main thread(Parent thread) to execute if join is mentioned it will not execute further it waits for the tread to finish its job\nDouble time join is not allowed, so always check if the thread is joinable using \nif(t1.joinable )\n{\n    t1.join\n}\n\n\n\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n     cout&lt;&lt;\"thread done\"&lt;&lt;endl;\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.detach();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n    return 0;\n}\nResult : main main continued \nThe result keep changing if we get this result which means the thread function print taking more time (probably due to the wait time given )to run than the main thread printing and returning\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     cout&lt;&lt;\"thread done\"&lt;&lt;endl;\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.detach();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n    return 0;\n}\nif the thread gets finished by 3seconds of wait period of main thread (PArent) Result could be  Main Main continued  Thread print  Thread done\nBut if the main function is returning before completing the thread then that thread will be suspended the result will be just main and main continued .\nAnd double time the detach is also not possible so always check if the thread is joinable if the thread is joinable then only the detaching also possible\n\n\n\nIf we create multiple threads in the program we donno which executes in what order\nMutual exclusion\nRace condition its a situation where two or more threads access to the same data and try to modify that data at the same time\nif there is any race condition we have to protect the data so that there wont be any unpredicted result\nMutex helps to avoid the race condition using the lock commands\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nint counterdata=0;\nvoid countData(int x)\n{\n    counterdata++;\n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \ncountdata will be updated by both thread t1 and t2 that forms the race condition . In order to avoid that we have to use mutex .\nThe critical section or critical reqion is where the data is updated at the same time by the threads .. To avoid that we have to use lock and unlock\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nusing namespace std;\nint counterdata=0;\nmutex mx;\nvoid countData(int x)\n{\n    mx.lock();\n    counterdata++;\n    mx.unlock();\n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \nHere which ever thred reaches first to the cpu then that thread lets say t1 will acquire the lock before t2.\ntry_lock If try_lock is used it returns true for the sucesfull lock aquisitions else return false.\nIf try_lock is not able to lock the mutex then it doesnt get blocked .\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nusing namespace std;\nint counterdata=0;\nmutex mx;\nvoid countData()\n{\n    if(mx.try_lock())\n    {\n        counterdata++;\n        mx.unlock();\n    }\n \n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \nHere the result is so random , since the thread wont wait for the locking to complete , so the actual result might also change\nIf i have a single core then how the thread parallally executes in c++ ?\n\nOn a single-core machine, threads do not execute truly in parallel. Instead, what gives the illusion of parallelism is something called “time-slicing” or “preemptive multitasking.”\nContext Switching: The operating system rapidly switches between running threads. It gives each thread a little “slice” of time to execute. When a thread’s time slice is up, its current state (context) is saved, and the CPU starts executing another thread.\nConcurrency vs. Parallelism: It’s important to differentiate between concurrency and parallelism. Concurrency is about dealing with a lot of things at once (which can be achieved through mechanisms like context switching), while parallelism is about doing a lot of things at once (which requires multiple cores or processors).\nBenefits on Single Core: Even on a single-core machine, using threads can be beneficial. For instance, if one thread is waiting for I/O (like reading a file or waiting for a network response), another thread can use the CPU. This way, the CPU isn’t idly waiting and can be used more efficiently.\nOverhead: Using multiple threads introduces overhead because of the need for context switches, synchronization mechanisms, etc. On a single-core machine, overusing threads (especially for tasks that are purely computational) can even lead to worse performance due to this overhead.\nLanguages & Libraries: In C++ specifically, the standard  library gives you tools to create and manage threads. But the behavior in terms of how these threads are scheduled and executed depends on the operating system’s scheduler.\nCooperative Multitasking: This is another form of multitasking where tasks yield control periodically or when idle to enable multiple tasks to run in a single-threaded environment. This approach depends more on the tasks being well-behaved and giving up control often.\n\n\n\n\nIt tries to lock all the loackable objets passed one by one in given order\nstd::try_lock(lm1,lm2....lmn)\nIf locked sucesfully function returns -1 otherwise it will return mutex index number which was not able to lock . if any one of the mutex is unable to lock ,it will release all the mutex which were previously locked . if try_lockresults in exception ,unlock is called for any locked object before rethrowing \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1,m2;\nint global_data=0;\n\nvoid function_Add(int x,mutex &m,int v)\n{\n    for(int i=0;i&lt;4;i++)\n    {\n        m.lock();\n        x=x+v;\n        global_data=x;\n        m.unlock();\n\n    }\n}\n\nvoid function_trylock_print()\n{\n    int lockResult=try_lock(m1,m2);\n    //Checks if try_lock is sucesful\n    if(lockResult==-1)\n    {\n        cout&lt;&lt;global_data&lt;&lt;endl;\n    }\n    m1.unlock();\n    m2.unlock();\n}\n\nint main()\n{\n    thread th1(function_Add,20,ref(m1),1);\n    thread th2(function_Add,20,ref(m2),2);\n    thread th3(function_trylock_print);\n    th1.join();\n    th2.join();\n    th3.join();\n    return 0;\n}\n\ntry_lock_for() -Tries the lock for specified duration - if waits for the amount of time mentioned to get the lock . The threads tries to get the lock for time mentioned in try_lock_for . Its used for time critical operations\ntry_lock_until - Waits until specified timeout time has been reached or the lock is aquired which ever comes first .if lock is quired return true else false\n\n\n\n\n\nSame thread can lock one mutex multiple times using recursive_mutex\nThe lock and unlock should match in recursive_mutex\nNo of times locking is system specific , if we reach that many times it will return system_error if we call lock() , if we call try_lock then return false\n\nrecursive_mutex\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nrecursive_mutex m;\n\nint function_recursion(int x)\n{\n    if(x&lt;=0)\n    {\n        return 1;\n    }\n    m.lock();\n    cout&lt;&lt;\"data=\"&lt;&lt;x&lt;&lt;endl;\n    function_recursion(--x);\n    m.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_recursion,3);\n    thread th4(function_recursion,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\n\n\nlock_guard&lt;mutex&gt;lock(m)where m is mutex - with lock_guard you dont have to unlock unlike the conventional way where we use unlockmethod - when the object is created it will lock the mutex ,the unlock happens in the destructor of the lock_guard ,it unlocks automatically when it goes out of scope since the object is created in stack.\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m;\nint counter=0;\nvoid function_lock_guard(int x)\n{\n  lock_guard&lt;mutex&gt;lock(m);\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n}\n\nint main()\n{\n\n    thread th3(function_lock_guard,3);\n    thread th4(function_lock_guard,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\nResult is : 1,2,3,4,5,6\n\n\n\n\nunique_lock&lt;mutex&gt;lock(m)where m is mutex it works just like the lock_guard\n\nLocking strategies \ndefer_lock -It does not lock the mutex ,locking should be done at later point\ntry_to_lock it aquires the mutex but without blocking \nadopt_lock it assumes the calling thread aquired the mutex\nit allows\n\ntime based locking such as  try_lock_for, try_lock_until\nRecurstive locking allowed \nMove the lock possible \nCondition_varaible -Notification to the threads \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m;\nint counter=0;\nvoid function_unique_lock(int x)\n{\n  unique_lock&lt;mutex&gt;lock(m,defer_lock);//owning the mutex but it doesnt lock \n  lock.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n}\n\nint main()\n{\n\n    thread th3(function_unique_lock,3);\n    thread th4(function_unique_lock,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\n\n\nPurpose  - Notify other threads notify_one() to single thread or notify_all() to all the thread - Waiting for some condition\nTo synchronise the thread all the thread should have common condition_variable\nIt uses unique_lock\nThe current thread waits and release the lock so that the other thread can execute\nIf we want to start particular thread to start first its best to use the condition_varaible since it wait on some condition variable\nfor this we can use wait ,wait_for ,wait_untilbased on our need\n\nThread Synchronisation example using condition_variable\n\nIn order to ensure thread synchronisation need to use condition_varaible In that wait and notify_allcommands wait takes argument lock and false to go for waiting and control will be given to next thread  once the notify_allcommand is executed the control gives back to the previous thread if the argument is true then the current thread wont wait and continue its execution \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nstatic int counterdata=1;\n\nmutex mx;\ncondition_variable cv;\n\nvoid PrintEvenData(int n)\n{\n         \n    for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==0;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n}\n\nvoid PrintOddData(int n)\n{\n         \n     for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==1;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n   \n}\nint main()\n{\n    thread th1(PrintEvenData,20);\n    thread th2(PrintOddData,20);\n     th1.join();\n    th2.join();\n    return 0;\n}\n\n\nIn order to ensure thread synchronisation need to use condition_varaible In that wait and notify_allcommands wait takes argument lock and false to go for waiting and control will be given to next thread  once the notify_allcommand is executed the control gives back to the previous thread if the argument is true then the current thread wont wait and continue its execution  Best use is producer consumer problem\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nstatic int counterdata=1;\n\nmutex mx;\ncondition_variable cv;\n\nvoid PrintEvenData(int n)\n{\n         \n    for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==0;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();//this is not needed since the unique_lock unlocks by itself in its destructor\n        cv.notify_all();//if more than one thread this could be used \n    }\n}\n\nvoid PrintOddData(int n)\n{\n         \n     for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==1;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n   \n}\nint main()\n{\n    thread th1(PrintEvenData,20);\n    thread th2(PrintOddData,20);\n     th1.join();\n    th2.join();\n    return 0;\n}\n\n\n\n\nIn multiple resource sharing scenarios if the threads are holding the resource and not able to release which is deadlock .\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\nint counter=0;\nvoid function_one(int x)\n{\n  m1.lock();\n  this_thread::sleep_for(chrono::seconds(3));\n  m2.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n  cout&lt;&lt;\"critical section two\"&lt;&lt;endl;\n  m1.unlock();\n  m2.unlock();\n}\n\nvoid function_two(int x)\n{\n  m2.lock();\n   this_thread::sleep_for(chrono::seconds(3));\n  m1.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n  cout&lt;&lt;\"critical section one\"&lt;&lt;endl;\n  m1.unlock();\n  m2.unlock();\n}\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\nIn function_one() locks m1 and goes for sleep by the time function_two locks m2\nIn function_two() locks m2 and goes for sleep\nThe function_one() waits for unlocking of m2 to execute the code in the critical section\nThe function_two() also waiting for unlocking of m1 to execute the code in the critical section\nThis situation is nothing but deadlock\n\nTo avoid this we shouldnt change the order of mutex locking (m1 and m2 in both the function)\n\n\n\nCritical section is one or collection of program statement which should be executed by only one thread or process at a time. Thread/process synchronize to access critical section if the data is common between the threads it is critical section , and if the data is used only for reading then its not considered as critical section but if there is a write operation between threads to update the same data then it becomes critical section\n\nBelow is the example of race condition we donno exactly the value of counter ,it will be impossible to get 8 it might be 3 or 5\n\n\n#include&lt;thread&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint counter=0;\nvoid function_one(int x)\n{\n counter+=x;\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_one,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\n\nHow to avoid this : using mutex\n\nmutex m1;\n\nint counter=0;\nvoid function_one(int x)\n{\n    m1.lock();\n    counter+=x;\n    m1.unlock();\n}\n\n\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_one,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\nHere lets say both the thread reached to lock at the same time , and one of them gets the access randomly to lock and access critical section lets say th1 got access then other thread is waiting and after writing counter it will release using unlock now the th2 can access by locking and continue to write .But here one thread is writing critical section at one time , only one thread at a time can execute if one of the thread dont unlock the other thread keeps waiting and goes to deadlock condition this is the reason the thread synchronisation is very important\n\nBut how do we ensure thread synchronisation without deadlock?\n\n\n\n\nIt allows to lock multiple mutex same time\nIt will not let to happen deadlock\nIt can use lock(), try_lock() or unlock()\nif one of them is not locked it will unlock all and tries another time by re arranging the sequence order of mutex locking . previously ,3 couldnt lock internally from next time when it tries it will try to lock first m3 then tries remaining and every time it ensures no deadlock scenario occurs.\n\nDeadlock example\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\n\nint counter=0;\nvoid function_one(int x)\n{\n    m2.lock();\n    this_thread::sleep_for(chrono::seconds(3));\n    m1.lock();\n    counter+=x;\n    m2.unlock();\n    m1.unlock();\n}\n\nvoid function_two(int x)\n{\n    m1.lock();\n    this_thread::sleep_for(chrono::seconds(3));\n    m2.lock();\n    counter+=x;\n    m1.unlock();\n    m2.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\n\nHow to avoid them\n\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\n\nint counter=0;\nvoid function_one(int x)\n{\n    lock(m1,m2);\n    this_thread::sleep_for(chrono::seconds(3));\n    counter+=x;\n    m1.unlock();\n    m2.unlock();\n\n}\n\nvoid function_two(int x)\n{\n   lock(m2,m1);\n    this_thread::sleep_for(chrono::seconds(3));\n    counter+=x;\n    m2.unlock();\n    m1.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\nExample\nNo deadlock  ex:1 - lock(m1,m2) - for thread 1 - lock(m1,m2)- for thread 2\nex:2 Thread1 - lock(m1,m2)-Th1 is locked m1\nThread 2 - lock(m2,m1)- Th2 is locked m2 it releases lock and tries after some time by the time thread 1 is released so the Th2 would be able to finish even it changes the order of locking and then release for Th1 vice versa\nDeadlock \n\n\n\n\n\nstd::promise Used to set values or exceptions\nstd::future It Wait for the promise It enquire promise if the values are available It gets the values from the promise\n\nHere is the simple program for promise and future to understand how the data is shared between two threads , the thread function_future which is calling getmethod internall waits until the data is available from the thread function_promise\n#include&lt;thread&gt;\n#include&lt;iostream&gt;\n#include &lt;future&gt;\n#include&lt;utility&gt;\n\nusing namespace std;\nvoid function_promise(promise&lt;int&gt;&&pObj)\n{\n  \npObj.set_value(10);\n\n}\n\nvoid function_future(future&lt;int&gt;&& obj)\n{\n   cout&lt;&lt;\"the value is=\"&lt;&lt;obj.get()&lt;&lt;endl;\n\n}\n\nint main()\n{\n    promise&lt;int&gt;pObj;\n    future&lt;int&gt;fObj=pObj.get_future();\n    thread t1(function_promise,move(pObj));\n    thread t2(function_future,move(fObj));\n    t1.join();\n    t2.join();\n    return 0;\n}\n\n\n\n\nProducer is the thread which gives the data Producer provides the data in the buffer\nConsumer is the thread which takes the data from the buffer in order to avoid the race condition here we use mutex Producer takes the lock and update the data and release mutex lock and notify to consumer .\n\nAfter the notification consumer goes and takes the data and consumer notify to producer back . - it goes until the producer wants to produce the data",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Advanced",
      "Multi Threading"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Advanced/multi_threading.html#multi-threading",
    "href": "C_Plus_Plus/Advanced/multi_threading.html#multi-threading",
    "title": "Multi Threading",
    "section": "",
    "text": "Purpose of Mutex : A mutex is used to coordinate mutually exclusive access to resources by multiple threads of execution. The mutex class is used to protect shared data from corruption due to simultaneous access by multiple threads.\nPurpose of producer consumer idiom : To facilitate threads that produce data and threads that consume data using a single common and coordinated container In the producer-consumer idiom one thread produces data and another consumes data, using one container to hold the data.\nWhat is the difference between sleep_for and sleep_until? sleep_for will sleep for a specified interval; sleep_until will sleep until a specified point in time. Both functions are in the this_thread namespace and both use objects from the chrono library for their arguments.\nHow does async return values from a thread? async returns values in a future object async uses the promise and future paradigm to return values to the caller.\nthread::join() method use case? The join() method blocks execution of the caller until the thread completes.\nWhat types qualify for use with std::atomic? std::atomic requires a trivial type. All primitive types are trivial, including bool, int, float, and double. std::atomic works with any trivial type. Trivial types include primitives such as bool, int, float, and double, as well as any class that uses the default constructor, copy constructor, copy assignment, and destructor.\n\n\n\nThread is useful for parallelism\nThread shall be created by below methods\n\nFunction pointer\nLambda function\nFunctor\nNon static member function\nStatic member function\n\nJoin helps to include the thread to main thread here the main thread is main function , if join is not present the main thread continue to execute before waiting for the t1 thread to finish .\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nvoid countFunction()\n{\n    for(int i=0;i&lt;10;i++)\n    {\n        counter++;\n        cout&lt;&lt;\"count function\"&lt;&lt;endl;\n    }\n}\n\n\nint main()\n{\ncout&lt;&lt;\"Main thread called\"&lt;&lt;endl;\n//Thread creation using function pointer\nthread t1(countFunction);\nt1.join();\ncout&lt;&lt;\"Main thread continued\"&lt;&lt;endl;\n}\nThread creation\nclass fClass\n{\n    public:\n    void operator()(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n\n    void printf(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n\n\n    static void printSt(int x)\n    {\n        cout&lt;&lt;x&lt;&lt;endl;\n    }\n};\n\nvoid print(int x)\n{\ncout&lt;&lt;x&lt;&lt;endl;\n}\nint main()\n{\n    //Thread creation using function pointer\n    thread t1(print,10);\n    t1.join;\n   //Thread creation using lambda\n   thread t3(([](int x){cout&lt;&lt;x&lt;&lt;endl;}),10);\n    t3.join();\n    //Thread creation using functor \n    thread t3(fClass(),10);\n    t3.join();\n    //Thread creation using non static member function \n    fClass obj;\n    thread t4(&fClass::printf,&obj,10);\n    t4.join();\n    //Thread creation using static member\n    thread t5(fClass::printSt,10);\n}\n\n\n\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.join();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n}\nResult : main  thread print - (waiting for 5sec) it prints after join  main continued \nWhen the thread created it starts running the thread and the control comes back to the main thread(Parent thread) to execute if join is mentioned it will not execute further it waits for the tread to finish its job\nDouble time join is not allowed, so always check if the thread is joinable using \nif(t1.joinable )\n{\n    t1.join\n}\n\n\n\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n     cout&lt;&lt;\"thread done\"&lt;&lt;endl;\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.detach();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n    return 0;\n}\nResult : main main continued \nThe result keep changing if we get this result which means the thread function print taking more time (probably due to the wait time given )to run than the main thread printing and returning\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n\nvoid print(int x)\n{\n    cout&lt;&lt;x&lt;&lt;endl;\n    cout&lt;&lt;\"thread print\"&lt;&lt;endl;\n     cout&lt;&lt;\"thread done\"&lt;&lt;endl;\n}\nint main()\n{\n    thread t1(print,10);\n    cout&lt;&lt;\"main\"&lt;&lt;endl;\n    t1.detach();\n    cout&lt;&lt;\"main continued\"&lt;&lt;endl;\n     this_thread::sleep_for(chrono::seconds(3));\n    return 0;\n}\nif the thread gets finished by 3seconds of wait period of main thread (PArent) Result could be  Main Main continued  Thread print  Thread done\nBut if the main function is returning before completing the thread then that thread will be suspended the result will be just main and main continued .\nAnd double time the detach is also not possible so always check if the thread is joinable if the thread is joinable then only the detaching also possible\n\n\n\nIf we create multiple threads in the program we donno which executes in what order\nMutual exclusion\nRace condition its a situation where two or more threads access to the same data and try to modify that data at the same time\nif there is any race condition we have to protect the data so that there wont be any unpredicted result\nMutex helps to avoid the race condition using the lock commands\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nint counterdata=0;\nvoid countData(int x)\n{\n    counterdata++;\n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \ncountdata will be updated by both thread t1 and t2 that forms the race condition . In order to avoid that we have to use mutex .\nThe critical section or critical reqion is where the data is updated at the same time by the threads .. To avoid that we have to use lock and unlock\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nusing namespace std;\nint counterdata=0;\nmutex mx;\nvoid countData(int x)\n{\n    mx.lock();\n    counterdata++;\n    mx.unlock();\n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \nHere which ever thred reaches first to the cpu then that thread lets say t1 will acquire the lock before t2.\ntry_lock If try_lock is used it returns true for the sucesfull lock aquisitions else return false.\nIf try_lock is not able to lock the mutex then it doesnt get blocked .\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\nusing namespace std;\nint counterdata=0;\nmutex mx;\nvoid countData()\n{\n    if(mx.try_lock())\n    {\n        counterdata++;\n        mx.unlock();\n    }\n \n}\nint main()\n{\n    thread t1(countData,10);\n    thread t2(countData,10);\n    t1.join();\n    t2.join();\n    cout&lt;&lt;counterdata&lt;&lt;endl;\n    return 0;\n} \nHere the result is so random , since the thread wont wait for the locking to complete , so the actual result might also change\nIf i have a single core then how the thread parallally executes in c++ ?\n\nOn a single-core machine, threads do not execute truly in parallel. Instead, what gives the illusion of parallelism is something called “time-slicing” or “preemptive multitasking.”\nContext Switching: The operating system rapidly switches between running threads. It gives each thread a little “slice” of time to execute. When a thread’s time slice is up, its current state (context) is saved, and the CPU starts executing another thread.\nConcurrency vs. Parallelism: It’s important to differentiate between concurrency and parallelism. Concurrency is about dealing with a lot of things at once (which can be achieved through mechanisms like context switching), while parallelism is about doing a lot of things at once (which requires multiple cores or processors).\nBenefits on Single Core: Even on a single-core machine, using threads can be beneficial. For instance, if one thread is waiting for I/O (like reading a file or waiting for a network response), another thread can use the CPU. This way, the CPU isn’t idly waiting and can be used more efficiently.\nOverhead: Using multiple threads introduces overhead because of the need for context switches, synchronization mechanisms, etc. On a single-core machine, overusing threads (especially for tasks that are purely computational) can even lead to worse performance due to this overhead.\nLanguages & Libraries: In C++ specifically, the standard  library gives you tools to create and manage threads. But the behavior in terms of how these threads are scheduled and executed depends on the operating system’s scheduler.\nCooperative Multitasking: This is another form of multitasking where tasks yield control periodically or when idle to enable multiple tasks to run in a single-threaded environment. This approach depends more on the tasks being well-behaved and giving up control often.\n\n\n\n\nIt tries to lock all the loackable objets passed one by one in given order\nstd::try_lock(lm1,lm2....lmn)\nIf locked sucesfully function returns -1 otherwise it will return mutex index number which was not able to lock . if any one of the mutex is unable to lock ,it will release all the mutex which were previously locked . if try_lockresults in exception ,unlock is called for any locked object before rethrowing \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1,m2;\nint global_data=0;\n\nvoid function_Add(int x,mutex &m,int v)\n{\n    for(int i=0;i&lt;4;i++)\n    {\n        m.lock();\n        x=x+v;\n        global_data=x;\n        m.unlock();\n\n    }\n}\n\nvoid function_trylock_print()\n{\n    int lockResult=try_lock(m1,m2);\n    //Checks if try_lock is sucesful\n    if(lockResult==-1)\n    {\n        cout&lt;&lt;global_data&lt;&lt;endl;\n    }\n    m1.unlock();\n    m2.unlock();\n}\n\nint main()\n{\n    thread th1(function_Add,20,ref(m1),1);\n    thread th2(function_Add,20,ref(m2),2);\n    thread th3(function_trylock_print);\n    th1.join();\n    th2.join();\n    th3.join();\n    return 0;\n}\n\ntry_lock_for() -Tries the lock for specified duration - if waits for the amount of time mentioned to get the lock . The threads tries to get the lock for time mentioned in try_lock_for . Its used for time critical operations\ntry_lock_until - Waits until specified timeout time has been reached or the lock is aquired which ever comes first .if lock is quired return true else false\n\n\n\n\n\nSame thread can lock one mutex multiple times using recursive_mutex\nThe lock and unlock should match in recursive_mutex\nNo of times locking is system specific , if we reach that many times it will return system_error if we call lock() , if we call try_lock then return false\n\nrecursive_mutex\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nrecursive_mutex m;\n\nint function_recursion(int x)\n{\n    if(x&lt;=0)\n    {\n        return 1;\n    }\n    m.lock();\n    cout&lt;&lt;\"data=\"&lt;&lt;x&lt;&lt;endl;\n    function_recursion(--x);\n    m.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_recursion,3);\n    thread th4(function_recursion,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\n\n\nlock_guard&lt;mutex&gt;lock(m)where m is mutex - with lock_guard you dont have to unlock unlike the conventional way where we use unlockmethod - when the object is created it will lock the mutex ,the unlock happens in the destructor of the lock_guard ,it unlocks automatically when it goes out of scope since the object is created in stack.\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m;\nint counter=0;\nvoid function_lock_guard(int x)\n{\n  lock_guard&lt;mutex&gt;lock(m);\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n}\n\nint main()\n{\n\n    thread th3(function_lock_guard,3);\n    thread th4(function_lock_guard,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\nResult is : 1,2,3,4,5,6\n\n\n\n\nunique_lock&lt;mutex&gt;lock(m)where m is mutex it works just like the lock_guard\n\nLocking strategies \ndefer_lock -It does not lock the mutex ,locking should be done at later point\ntry_to_lock it aquires the mutex but without blocking \nadopt_lock it assumes the calling thread aquired the mutex\nit allows\n\ntime based locking such as  try_lock_for, try_lock_until\nRecurstive locking allowed \nMove the lock possible \nCondition_varaible -Notification to the threads \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m;\nint counter=0;\nvoid function_unique_lock(int x)\n{\n  unique_lock&lt;mutex&gt;lock(m,defer_lock);//owning the mutex but it doesnt lock \n  lock.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n}\n\nint main()\n{\n\n    thread th3(function_unique_lock,3);\n    thread th4(function_unique_lock,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\n\n\nPurpose  - Notify other threads notify_one() to single thread or notify_all() to all the thread - Waiting for some condition\nTo synchronise the thread all the thread should have common condition_variable\nIt uses unique_lock\nThe current thread waits and release the lock so that the other thread can execute\nIf we want to start particular thread to start first its best to use the condition_varaible since it wait on some condition variable\nfor this we can use wait ,wait_for ,wait_untilbased on our need\n\nThread Synchronisation example using condition_variable\n\nIn order to ensure thread synchronisation need to use condition_varaible In that wait and notify_allcommands wait takes argument lock and false to go for waiting and control will be given to next thread  once the notify_allcommand is executed the control gives back to the previous thread if the argument is true then the current thread wont wait and continue its execution \n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nstatic int counterdata=1;\n\nmutex mx;\ncondition_variable cv;\n\nvoid PrintEvenData(int n)\n{\n         \n    for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==0;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n}\n\nvoid PrintOddData(int n)\n{\n         \n     for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==1;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n   \n}\nint main()\n{\n    thread th1(PrintEvenData,20);\n    thread th2(PrintOddData,20);\n     th1.join();\n    th2.join();\n    return 0;\n}\n\n\nIn order to ensure thread synchronisation need to use condition_varaible In that wait and notify_allcommands wait takes argument lock and false to go for waiting and control will be given to next thread  once the notify_allcommand is executed the control gives back to the previous thread if the argument is true then the current thread wont wait and continue its execution  Best use is producer consumer problem\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nstatic int counterdata=1;\n\nmutex mx;\ncondition_variable cv;\n\nvoid PrintEvenData(int n)\n{\n         \n    for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==0;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();//this is not needed since the unique_lock unlocks by itself in its destructor\n        cv.notify_all();//if more than one thread this could be used \n    }\n}\n\nvoid PrintOddData(int n)\n{\n         \n     for(;counterdata&lt;n;)\n    {    \n        unique_lock&lt;mutex&gt; lock(mx);\n        cv.wait(lock,[](){return counterdata%2==1;});\n        cout&lt;&lt;counterdata&lt;&lt;endl;\n        counterdata++;\n        lock.unlock();\n        cv.notify_all();\n    }\n   \n}\nint main()\n{\n    thread th1(PrintEvenData,20);\n    thread th2(PrintOddData,20);\n     th1.join();\n    th2.join();\n    return 0;\n}\n\n\n\n\nIn multiple resource sharing scenarios if the threads are holding the resource and not able to release which is deadlock .\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\nint counter=0;\nvoid function_one(int x)\n{\n  m1.lock();\n  this_thread::sleep_for(chrono::seconds(3));\n  m2.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n  cout&lt;&lt;\"critical section two\"&lt;&lt;endl;\n  m1.unlock();\n  m2.unlock();\n}\n\nvoid function_two(int x)\n{\n  m2.lock();\n   this_thread::sleep_for(chrono::seconds(3));\n  m1.lock();\n  for(int i=0;i&lt;x;i++)\n  {\n        counter++;\n        cout&lt;&lt;counter&lt;&lt;endl;\n  }\n  cout&lt;&lt;\"critical section one\"&lt;&lt;endl;\n  m1.unlock();\n  m2.unlock();\n}\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,3);\n    th3.join();\n    th4.join();\n    return 0;\n}\n\nIn function_one() locks m1 and goes for sleep by the time function_two locks m2\nIn function_two() locks m2 and goes for sleep\nThe function_one() waits for unlocking of m2 to execute the code in the critical section\nThe function_two() also waiting for unlocking of m1 to execute the code in the critical section\nThis situation is nothing but deadlock\n\nTo avoid this we shouldnt change the order of mutex locking (m1 and m2 in both the function)\n\n\n\nCritical section is one or collection of program statement which should be executed by only one thread or process at a time. Thread/process synchronize to access critical section if the data is common between the threads it is critical section , and if the data is used only for reading then its not considered as critical section but if there is a write operation between threads to update the same data then it becomes critical section\n\nBelow is the example of race condition we donno exactly the value of counter ,it will be impossible to get 8 it might be 3 or 5\n\n\n#include&lt;thread&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nint counter=0;\nvoid function_one(int x)\n{\n counter+=x;\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_one,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\n\nHow to avoid this : using mutex\n\nmutex m1;\n\nint counter=0;\nvoid function_one(int x)\n{\n    m1.lock();\n    counter+=x;\n    m1.unlock();\n}\n\n\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_one,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\nHere lets say both the thread reached to lock at the same time , and one of them gets the access randomly to lock and access critical section lets say th1 got access then other thread is waiting and after writing counter it will release using unlock now the th2 can access by locking and continue to write .But here one thread is writing critical section at one time , only one thread at a time can execute if one of the thread dont unlock the other thread keeps waiting and goes to deadlock condition this is the reason the thread synchronisation is very important\n\nBut how do we ensure thread synchronisation without deadlock?\n\n\n\n\nIt allows to lock multiple mutex same time\nIt will not let to happen deadlock\nIt can use lock(), try_lock() or unlock()\nif one of them is not locked it will unlock all and tries another time by re arranging the sequence order of mutex locking . previously ,3 couldnt lock internally from next time when it tries it will try to lock first m3 then tries remaining and every time it ensures no deadlock scenario occurs.\n\nDeadlock example\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\n\nint counter=0;\nvoid function_one(int x)\n{\n    m2.lock();\n    this_thread::sleep_for(chrono::seconds(3));\n    m1.lock();\n    counter+=x;\n    m2.unlock();\n    m1.unlock();\n}\n\nvoid function_two(int x)\n{\n    m1.lock();\n    this_thread::sleep_for(chrono::seconds(3));\n    m2.lock();\n    counter+=x;\n    m1.unlock();\n    m2.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\n\nHow to avoid them\n\n#include&lt;thread&gt;\n#include&lt;mutex&gt;\n#include&lt;iostream&gt;\n#include&lt;chrono&gt;\n#include&lt;condition_variable&gt;\nusing namespace std;\n\nmutex m1;\nmutex m2;\n\nint counter=0;\nvoid function_one(int x)\n{\n    lock(m1,m2);\n    this_thread::sleep_for(chrono::seconds(3));\n    counter+=x;\n    m1.unlock();\n    m2.unlock();\n\n}\n\nvoid function_two(int x)\n{\n   lock(m2,m1);\n    this_thread::sleep_for(chrono::seconds(3));\n    counter+=x;\n    m2.unlock();\n    m1.unlock();\n}\n\nint main()\n{\n\n    thread th3(function_one,3);\n    thread th4(function_two,5);\n    th3.join();\n    th4.join();\n    cout&lt;&lt;counter&lt;&lt;endl;\n    return 0;\n}\nExample\nNo deadlock  ex:1 - lock(m1,m2) - for thread 1 - lock(m1,m2)- for thread 2\nex:2 Thread1 - lock(m1,m2)-Th1 is locked m1\nThread 2 - lock(m2,m1)- Th2 is locked m2 it releases lock and tries after some time by the time thread 1 is released so the Th2 would be able to finish even it changes the order of locking and then release for Th1 vice versa\nDeadlock \n\n\n\n\n\nstd::promise Used to set values or exceptions\nstd::future It Wait for the promise It enquire promise if the values are available It gets the values from the promise\n\nHere is the simple program for promise and future to understand how the data is shared between two threads , the thread function_future which is calling getmethod internall waits until the data is available from the thread function_promise\n#include&lt;thread&gt;\n#include&lt;iostream&gt;\n#include &lt;future&gt;\n#include&lt;utility&gt;\n\nusing namespace std;\nvoid function_promise(promise&lt;int&gt;&&pObj)\n{\n  \npObj.set_value(10);\n\n}\n\nvoid function_future(future&lt;int&gt;&& obj)\n{\n   cout&lt;&lt;\"the value is=\"&lt;&lt;obj.get()&lt;&lt;endl;\n\n}\n\nint main()\n{\n    promise&lt;int&gt;pObj;\n    future&lt;int&gt;fObj=pObj.get_future();\n    thread t1(function_promise,move(pObj));\n    thread t2(function_future,move(fObj));\n    t1.join();\n    t2.join();\n    return 0;\n}\n\n\n\n\nProducer is the thread which gives the data Producer provides the data in the buffer\nConsumer is the thread which takes the data from the buffer in order to avoid the race condition here we use mutex Producer takes the lock and update the data and release mutex lock and notify to consumer .\n\nAfter the notification consumer goes and takes the data and consumer notify to producer back . - it goes until the producer wants to produce the data",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Advanced",
      "Multi Threading"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Graphs/bfs.html",
    "href": "C_Plus_Plus/Graphs/bfs.html",
    "title": "BFS",
    "section": "",
    "text": "#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n\nvoid bfs(std::vector&lt;std::vector&lt;int&gt;&gt; &adj, int start)\n{\n    std::vector&lt;bool&gt; visited(adj.size(), false);\n    std::queue&lt;int&gt; q;\n    std::cout &lt;&lt; \"BFS Traversal starting from vertex \" &lt;&lt; start &lt;&lt; \":\\n\";\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty())\n    {\n        int curr = q.front();\n        q.pop();\n        std::cout &lt;&lt; \"Processing vertex \" &lt;&lt; curr &lt;&lt; \":\\n\";\n\n        for (int i = 0; i &lt; adj[curr].size(); i++)\n        {\n            if (adj[curr][i] == 1 && visited[i] == 0)\n            {\n                visited[i] = true;\n                q.push(i);\n                std::cout &lt;&lt; \"  -&gt; Visiting vertex \" &lt;&lt; i &lt;&lt; \"\\n\";\n            }\n        }\n    }\n    std::cout &lt;&lt; \"BFS Traversal Complete.\\n\";\n\n}\n\n\nint main()\n{\n    std::vector&lt;std::vector&lt;int&gt;&gt; adj =\n    {\n        {0, 1, 1, 0, 0, 0},\n        {1, 0, 0, 1, 0, 0},\n        {1, 0, 0, 1, 0, 0},\n        {0, 1, 1, 0, 1, 1},\n        {0, 0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 0, 0}};\n    bfs(adj, 2); //2 is the starting vertices\n    return 0;\n\n}\nOutput :\nBFS Traversal starting from vertex 2:\nProcessing vertex 2:\n  -&gt; Visiting vertex 0\n  -&gt; Visiting vertex 3\nProcessing vertex 0:\n  -&gt; Visiting vertex 1\nProcessing vertex 3:\n  -&gt; Visiting vertex 4\n  -&gt; Visiting vertex 5\nProcessing vertex 1:\nProcessing vertex 4:\nProcessing vertex 5:\nBFS Traversal Complete.",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Graphs",
      "BFS"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Graphs/bfs.html#bfs-concept",
    "href": "C_Plus_Plus/Graphs/bfs.html#bfs-concept",
    "title": "BFS",
    "section": "",
    "text": "#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n\nvoid bfs(std::vector&lt;std::vector&lt;int&gt;&gt; &adj, int start)\n{\n    std::vector&lt;bool&gt; visited(adj.size(), false);\n    std::queue&lt;int&gt; q;\n    std::cout &lt;&lt; \"BFS Traversal starting from vertex \" &lt;&lt; start &lt;&lt; \":\\n\";\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty())\n    {\n        int curr = q.front();\n        q.pop();\n        std::cout &lt;&lt; \"Processing vertex \" &lt;&lt; curr &lt;&lt; \":\\n\";\n\n        for (int i = 0; i &lt; adj[curr].size(); i++)\n        {\n            if (adj[curr][i] == 1 && visited[i] == 0)\n            {\n                visited[i] = true;\n                q.push(i);\n                std::cout &lt;&lt; \"  -&gt; Visiting vertex \" &lt;&lt; i &lt;&lt; \"\\n\";\n            }\n        }\n    }\n    std::cout &lt;&lt; \"BFS Traversal Complete.\\n\";\n\n}\n\n\nint main()\n{\n    std::vector&lt;std::vector&lt;int&gt;&gt; adj =\n    {\n        {0, 1, 1, 0, 0, 0},\n        {1, 0, 0, 1, 0, 0},\n        {1, 0, 0, 1, 0, 0},\n        {0, 1, 1, 0, 1, 1},\n        {0, 0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 0, 0}};\n    bfs(adj, 2); //2 is the starting vertices\n    return 0;\n\n}\nOutput :\nBFS Traversal starting from vertex 2:\nProcessing vertex 2:\n  -&gt; Visiting vertex 0\n  -&gt; Visiting vertex 3\nProcessing vertex 0:\n  -&gt; Visiting vertex 1\nProcessing vertex 3:\n  -&gt; Visiting vertex 4\n  -&gt; Visiting vertex 5\nProcessing vertex 1:\nProcessing vertex 4:\nProcessing vertex 5:\nBFS Traversal Complete.",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Graphs",
      "BFS"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Graphs/bfs.html#find-shortest-path-in-a-grid",
    "href": "C_Plus_Plus/Graphs/bfs.html#find-shortest-path-in-a-grid",
    "title": "BFS",
    "section": "2 Find shortest path in a grid",
    "text": "2 Find shortest path in a grid\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n/*\n*In a 2D grid (or matrix), each cell can be represented as (row, column):\n    The row index corresponds to the vertical position.\n    The column index corresponds to the horizontal position.\n\n*2D grid\n    (0,0) (0,1) (0,2)\n    (1,0) (1,1) (1,2)\n    (2,0) (2,1) (2,2)\n\n* If you are at (1,1) (the center), neighboring cells are \ndetermined by how the indices change for rows and columns.\n*\n* Cardinal Directions:\n    To move up, down, left, or right, \n    you only change one coordinate at a time:\n        Up: Move to the row above → Decrease the row index → (-1, 0)\n        Down: Move to the row below → Increase the row index → (1, 0)\n        Left: Move to the column left → Decrease the column index → (0, -1)\n        Right: Move to the column right → Increase the column index → (0, 1)\n\n* Diagonal Directions:\nTo move diagonally, both the row and column indices change:\n    Top-Left: Move up and left → (-1, -1)\n    Top-Right: Move up and right → (-1, 1)\n    Bottom-Left: Move down and left → (1, -1)\n    Bottom-Right: Move down and right → (1, 1)\n */\nint bfsShortestPath(std::vector&lt;std::vector&lt;int&gt;&gt; &grid)\n{\n    std::queue&lt;std::pair&lt;int, int&gt;&gt; q;\n    int n = grid.size();\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; directions{{-1, -1}, {1, 1}, {1, -1}, \n    {-1, 1},{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n\n    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1)\n        return -1;\n    q.push({0, 0});\n    grid[0][0] = 1;\n    while (!q.empty())\n    {\n        auto [x,y] = q.front();\n        int dist = grid[x][y];\n        q.pop();\n        if (x == n - 1 && y == n - 1)\n        {\n            std::cout &lt;&lt; \"BFS Traversal complete.\\n\";\n            return dist;\n        }\n\n        for (auto [dx,dy] : directions)\n        {\n            int nx = dx + x;\n            int ny = dy + y;\n            if (nx &gt;= 0 && ny &gt;= 0 && nx &lt; n && ny &lt; n && grid[nx][ny] == 0)\n            {\n                grid[nx][ny] = dist + 1;\n                q.push({nx, ny});\n            }\n\n        }\n    }\n\n    std::cout &lt;&lt; \"BFS Traversal ended- No valid path.\\n\";\n    return -1;\n}\n\n\nint main()\n{\n    std::vector&lt;std::vector&lt;int&gt;&gt; grid =\n    {\n        {0, 1, 1},\n        {1, 0, 1},\n        {1, 1, 0}\n    };\n\n    int dist = bfsShortestPath(grid);\n    std::cout &lt;&lt; \"Shortest Path \" &lt;&lt; dist;\n    return 0;\n\n}\nOutput\n\nBFS Traversal complete.\nShortest Path 3",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Graphs",
      "BFS"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Graphs/bfs.html#bfs-adjucency",
    "href": "C_Plus_Plus/Graphs/bfs.html#bfs-adjucency",
    "title": "BFS",
    "section": "3 BFS adjucency",
    "text": "3 BFS adjucency\n#include&lt;iostream&gt;\n#include&lt;queue&gt;\n\n// BFS function for adjacency list representation, printing actual vertex labels\nvoid BFS_adjacencyList(const std::vector&lt;std::vector&lt;int&gt;&gt;& adjList, int v, const std::unordered_map&lt;int, std::string&gt;& vertexLabels) {\n    std::queue&lt;int&gt; q;\n    int u;\n    q.push(v);\n    int size = adjList.size();\n    std::vector&lt;int&gt; visited(size, 0);\n    visited[v] = 1;\n\n    while (!q.empty()) {\n        u = q.front();\n        q.pop();\n\n        // Print the label associated with the vertex instead of the index\n        std::cout &lt;&lt; \"Visited Vertex: \" &lt;&lt; vertexLabels.at(u) &lt;&lt; std::endl;\n\n        // Explore the neighbors of vertex 'u'\n        for (int neighbor : adjList[u]) {\n            if (visited[neighbor] == 0) {\n                q.push(neighbor);\n                visited[neighbor] = 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n    std::unordered_map&lt;int, std::string&gt; vertexLabels = {\n        {0, \"A\"},\n        {1, \"B\"},\n        {2, \"C\"},\n        {3, \"D\"},\n        {4, \"E\"},\n        {5, \"F\"},\n        {6, \"G\"},\n         {7,\"I\"}\n    };\n\n    // Graph represented using an adjacency list\n    std::vector&lt;std::vector&lt;int&gt;&gt; adjList = {\n        {},         // Vertex 0 (no edges)\n        {2, 3},     // Vertex 1 is connected to vertices 2 and 3\n        {1, 4},     // Vertex 2 is connected to vertices 1 and 4\n        {1, 4},     // Vertex 3 is connected to vertices 1 and 4\n        {2, 3, 5, 6}, // Vertex 4 is connected to vertices 2, 3, 5, 6\n        {4},        // Vertex 5 is connected to vertex 4\n        {4}         // Vertex 6 is connected to vertex 4\n    };\n\n    std::cout&lt;&lt;\"adjacencylist values\"&lt;&lt;std::endl;\n    BFS_adjacencyList(adjList,2,vertexLabels); //2 is the starting vertices\n    }\nOutput:\nadjacencylist values\nVisited Vertex: C\nVisited Vertex: B\nVisited Vertex: E\nVisited Vertex: D\nVisited Vertex: F\nVisited Vertex: G",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Graphs",
      "BFS"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Graphs/bfs.html#find-number-of-islands",
    "href": "C_Plus_Plus/Graphs/bfs.html#find-number-of-islands",
    "title": "BFS",
    "section": "4 Find number of Islands",
    "text": "4 Find number of Islands\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;queue&gt;\n/*\n*Given an m x n 2D binary grid grid which represents a map of '1's (land)\n* and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent\n*  lands horizontally or vertically. You may assume all four edges\n* of the grid are all surrounded by water.\n*\n* grid =\n* [\n* [1, 1, 0, 0, 0],\n  [1, 1, 0, 0, 0],\n  [0, 0, 1, 0, 0],\n  [0, 0, 0, 1, 1]\n]\n */\nvoid bfsFindNoOfIsland(std::vector&lt;std::vector&lt;int&gt;&gt; &grid, int x, int y)\n{\n    std::queue&lt;std::pair&lt;int, int&gt;&gt; q;\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; directions = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n    q.push({x, y});\n    grid[x][y] = 0;\n    while (!q.empty())\n    {\n        auto [cx,cy] = q.front();\n        q.pop();\n\n        for (auto [dx,dy] : directions)\n        {\n            int nx = dx + cx;\n            int ny = dy + cy;\n            // Check if the next cell is within bounds and is land (1)\n            if (nx &gt;= 0 && ny &gt;= 0 && nx &lt; grid.size() && ny &lt; grid[0].size() && grid[nx][ny] == 1)\n            {\n                // Mark the cell as visited\n                grid[nx][ny] = 0;\n                q.push({nx, ny});\n            }\n        }\n    }\n}\n\n// Function to count the number of islands\nint numIslands(std::vector&lt;std::vector&lt;int&gt;&gt; &grid)\n{\n    int islands = 0;\n\n    // Traverse the grid\n    for (int i = 0; i &lt; grid.size(); i++)\n    {\n        for (int j = 0; j &lt; grid[i].size(); j++)\n        {\n            // If we find land (1), perform BFS and increment the island count\n            if (grid[i][j] == 1)\n            {\n                bfsFindNoOfIsland(grid, i, j);\n                islands++;\n            }\n        }\n    }\n    return islands;\n}\n\nint main()\n{\n    std::vector&lt;std::vector&lt;int&gt;&gt; grid =\n    {\n        {1, 1, 0, 0, 0},\n        {1, 1, 0, 0, 0},\n        {0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 1},\n    };\n\n    auto islands = numIslands(grid);\n    std::cout &lt;&lt; \"No of islands \" &lt;&lt; islands;\n    return 0;\n\n}\nOutput:\nNo of islands 3",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Graphs",
      "BFS"
    ]
  },
  {
    "objectID": "C_Plus_Plus/Graphs/bfs.html#shortest-path-words",
    "href": "C_Plus_Plus/Graphs/bfs.html#shortest-path-words",
    "title": "BFS",
    "section": "5 Shortest path words",
    "text": "5 Shortest path words\n\n/*Problem: Word Ladder\nDescription: Given two words, beginWord and endWord, and a dictionary of words,\nfind the length of the shortest transformation sequence from beginWord to endWord.\nEach transformed word must be in the word list, and only one letter can be changed at a time.*/\n#include &lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;vector&gt;\n#include&lt;unordered_set&gt;\n#include&lt;queue&gt;\n\nint shortestTransformation(std::string beginWord, std::string endWord, std::vector&lt;std::string&gt; &wordList)\n{\n    std::unordered_set&lt;std::string&gt; wordSet(wordList.begin(), wordList.end());\n    if (!wordSet.count(endWord))\n    {\n        return 0;\n    }\n    std::queue&lt;std::pair&lt;std::string, int&gt;&gt; q;\n    q.push({beginWord, 1});\n\n    while (!q.empty())\n    {\n        auto [word,length] = q.front();\n        q.pop();\n\n        if (word == endWord)\n        {\n            return length;\n        }\n\n        for (int i = 0; i &lt; word.length(); i++)\n        {\n            std::string temp = word;\n            for (char c = 'a'; c &lt;= 'z'; c++)\n            {\n                temp[i] = c;\n\n                if (wordSet.count(temp))\n                {\n                    q.push({temp, length + 1});\n                    wordSet.erase(temp);\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    std::vector&lt;std::string&gt; wordList{\"hot\", \"dot\", \"dog\", \"log\", \"pog\"};\n    auto shortLength = shortestTransformation(\"hit\", \"pog\", wordList);\n    std::cout &lt;&lt; \"Shortest Length : \" &lt;&lt; shortLength &lt;&lt; std::endl;\n\n}\nOutput:\nShortest Length : 5",
    "crumbs": [
      "{{< fa house >}} Home",
      "C Plus Plus",
      "Graphs",
      "BFS"
    ]
  },
  {
    "objectID": "Autosar/DCM.html",
    "href": "Autosar/DCM.html",
    "title": "Diagnostic communication manager",
    "section": "",
    "text": "Diagnostic session control module ensures diagnostic data flow and manages the diagnostic states, especially diagnostic sessions and security states .\nThe DCM module provides the OSI-layers 5 to 7\nOSI Layers and Diagnostic Protocols linking\n\n7- UDS 14229\n6-\n5- ISO 15765-3 - UDS on CAN\n4- ISO 15765-2\n3- ISO 15765-2\n2- CAN procotol, LIN Protocol, Flexray, MOST\n1- CAN procotol, LIN Protocol, Flexray, MOST \n\nThe dcm module receives diagnostic messages from the pdur module . once the dcm gets all the data it sends a message back throught he PduR module\nPdur (protocol data unit router) : The PduR module provides functions to trasmit and receive diagnositc data\nCommunication Manager(ComM): The ComM module provides functions such that the dcm can indicate the states “active” and “inactive” for diagnostic communication\nDCM handles the communication requirements such as Full/Silent/No-Communication. dcm module provides the functionality to enable and disable diagnositc communication if requested by the ComM module.\nDCM indicates to the BswM a communication mode change and notifies if the dcm is initailised due to jump from bootloader to application\n\n\n\nIf the diagnostic service is not sucesful due to any reason the corresponding NRC will be set and sent along with response to the diagnostic request\n\n\n\n\nDCM is devided in to 3 parts\n\n\nDSL-Diagnostic Session Layer\n\n\ncontrols diagnostic protocol timing and manages the security and sessions\n\n\nDiagnostic Service Dispatcher\n\n\nreceives new diagnositc request over a network and forwards it to a data processor\nTransmits a diagnositc response over a netowork when triggered by the data processor(DSP)\n\n\nDiagnostic Service Processing\n\n\nThe DSP submodule handles the actual diagnostic service requests . \n\n\n\n\n\n\n\nSessions handling as required by ISO 14229 and ISO 15765-3\nApplication layer timing handling as required by ISO 14229 and ISO 15765-3\nSpecific response behabiors as required by iso 14229 and iso 15765-3\n\n\n\n\nThe DSL has the following interaction wwith other modules : ##### PduR Module : - PduR module provides data of incoming diagnostic requests - The DSL submodule triggers output of diagnostic responses ##### DSD Submodule : - The DSL informs the dsd about incoming requests and provides the data - the DSD submodule triggers output of diagnostic responses ##### DSP submodule : - The DSL provides access to security and session state ##### ComM module : - The DSL guarantees the communication behavior required by the ComM module\n\n\n\n\n\n\nForwards request from the PduR module to DSD\nConcurrent test present (Keep alive logic - 3E service from ISO 14229) - if the 3E service requested with suppressPosRspMsgIndication bit set to be true (subfunction 0x80) ,DSL reset S3 server timing. also it shall not forward this request to DSD fof further interpretation\n\n\n\n\n\nForwards responses from the dsd to the PduR - via api PduR_DcmTransmit\nGuarantee response timing to tester if the service takes more time to respond then DSL shall send NRC 0x78 when reaching the response time P2 server max( DcmDspSessionP2ServerMax) from the next 0x78 waits for P2* server timeDcmDspSessionP2StarServerMax . DSL sends the negative responses as required from a separate buffer. The Max number of response pending(0x78) is configurable using DcmDslDiagRespMaxNumRespPend in order to avoid the deadlocks in the application. Once it reaches the Resp pending counter it shall send NRC (0x10) indicating general reject.\n\n\n\n\n\nManage security level\n\n\n\n\n\nManage session state :DSL get the current active session via Dcm_GetSesCtrlType() and set a new session through DslInternal_SetSesCtrlType() During dcm initialisation the default state is et which is Default session(0x01) when ever a non deault session is active and when the session timeout (S3 server)timing reaches without receiving any diag request , the DSL shall reset to the deault session by calling mode switch api of mode switch interface\nKeep track of active nond efault sessions\nAllow modifying timings DCM mdoule handle the following protocol timing parameter P2ServerMin,P2ServerMax,P2*ServerMin,P2*ServerMax,S3Server Generally these parameter set as\n\n\n\n\n\nHandling of Full/Silent/No Communication\nIndicating of active/inactive diagnostic\nEnabling/Disabling all kinds of diagnostic transmissions\n\n\n\n\n\n\nIt checks the validity of an incoming diagnostic request such as - Verification of diagnostic session - Security access levels - Application permission And keeps track of the progress of a service request execution\nThe DSD shall process only valid requests and shall reject invalid ones\n\n\n\nReceive a request message and transmit positive response message\n\nThe DSD ensures the validity of the request message.In this case if the request is valid the response will be positive .The request will be forwarded to the data process in the DSP. after DSP completes it triggers the transmission of response message by the DSD. If the response processing takes more time by the DSP may be waiting for read/write operation to eeprom then the response pending is covered by the DSL . When the request diag received the corresponding DcmPduId is blocked by the DSL .During the processing of this request , no other request of the same protocol type can be received, until the corresponding response message is sent and the DcmPduId if released again\n\nReceive a request message and supress the positive response\n\nIf the suppress positive response bit is set in the diag request in msb bit of sub function parameter .this kind of message completely handled by the DSD\n\nReceieve a request message and suppress the negative response\n\nIn case of functional addressing the DSD shall suppress the negative response for NRC 0x11 , 0x12 and 0x31\n\nReceive a request messahe and trasmit the negative response message\n\nDiag request is not valid or any condition not met to send the positive response the negative responses will be sent . In this case the DSP trigger a negative response with nrc indicating why the request was rejected . In case of 0x22 service if more than one did read operation is requested and if not all of the requested read did not failed only for the passed did the response will be sent .\n\nSend a positive response message without corresponding request\n\nThere are two services in the UDS protocol where multiole responses are sent for only one request . One service is used to enable(and disable)an event or time triggered transmission of another service , which is sent byt he ECU without a corresponding request. These services are \n\nRead Data by periodic identifier(0x2A)\nReponse on Event(0x86) These service handling is controlled by the DSL.However,DSD also provides the possibility to generate a response without a corresponding request.\n\n\nSegemented responses(Paged buffer):\n\nServices such as 0x19 and 0x36 exchange huge amount of data. So in this case the ecu internal buffer must be large enough to keep the longest data message which is to be exchnaged and the complete buffer is filled before the transmission is started . In a more RAM memory saving approach the buffer is filled only partly , transmitted partly and then refilled partly and so on. This paging mechanism rewuires only a reduced amount of memory but demands a well defined reaction time for buffer refilling . The user can decide whether to use the linear buffer or paged bugger for diagnostic\n\n#### DSD interaction with other modules\n\nDelegates the processing of request to the DSP\nKeeps track of request processing\nTransmit the response of the application to the DSL\n\n#### Functional description\n\nThe DSD shall be triggered by the DSL , if a new diagnostic message is recognised .\nThe DSD will sart processing by analyzing the diagnostic service indentifier contained in the received diagnositc message\nif the newly received the diagnositc request sid is not supported then the DSD shall transmit the negative response with NRC 0x11 to the DSL.\nVerification Functionality :The DSD accept service only if below 3 verifications are passed\n\nVerification of the Diagnostic session: On receiving the uds request dsd gets the current diagnostic session using api Dcm_GetSesCtrlType and verify whether the requested service and sub function are allowed in the current diagnostic session or not . (Note :0x10 service handling not part of DSD) If the received diag service is not allowed in the current diag session the DSD transmit the negative response with NRC 0x7F (service not supported in the active session)to the DSL submodule. If the received diag service is allowed in the current diag session but the sub function is not allowed in the current diag session then the DSD transmit the negative response with NRC 0x7E (sub function not supported in the active session)to the DSL submodule.\nVerification of the service security access levels:\n\nThe DSD checks the current security level with api Dcm_GetSecurityLevel() If the received diag service is not allowed in the current security level then the DSD shall transmit negative response with NRC 0x33 (Security access denied) to the DSL submodule\n\nIf the received diag service is n allowed in the current security level but the requested sub function is not allowed then the DSD shall transmit negative response with NRC 0x33 (Security access denied) to the DSL submodule DSD checks whether subfunction supported , if not supported NRC 0x12 will be sent . DSD checks minimum message length\nVerification of the application environment/Permission Before processing the diag request the application requested to check permission /environment eg: if ecu is in run state the diag service execution not allowed , vehicle speed is higher then the service is not allowed to execute(eg : service 11)\n\n\nThe DSD pass the diag request to DSP service interpretor\nThe execution of the DSP service interpreter can have the results\n\nPositive result or\nNegative result\n\nFollowing possible responses can be assembled\n\nPositive response : DSP indicate calling Dcm_ExternalProcessingDone().The parameter Dcm_MsgContextType contains the diagnostic (response)messgae . Then the DSD adds the response SIDand then response data stream (returned by the application)in the parameter Dcm_MsgContextType\nNegative response : The DSP triggers specific NRC to the DSD . The DSD handle all the supported NRC from the application and defined in the Dcm_NegativeResponseCodeType.\nSuppression of response in case of a negative result of the execution and active functional addressing the dsd submodule shall activate the suppression of the following negative responses:\n\n\nNRC 0x011 - service not supported\nNRC 0x12 - subfunction not supported\nNRC 0x31 - request out of range\n\n\nno Response :\nInitiate transmission\n\nthe DSD shall forward the diagnostic(response)message (positive or negative response) to the DSL.\nthe DSL shall forward the diagnostic(response)message (positive or negative response)further to the PduR module by executing a DSL transmit functionality.\nThe DSL will receive the confirmation by the PduR upon forwarding the dada\n\nthe DSL shall forward the received confirmation from the PduR to the dsd submodule.\nthe dsd shall forward the confirmation via the internal function DspInternal_DcmConfirmation() to the DSP submodule.\nIn case no diagnostic(response)message shall be sent(suppression of responses)the DSL submodule shall not transmit any response.\n\n\n\n\n\n\n\n\nWhen dsd request the dsp to process the diag request .it executed following basic process 1. analyze the received request message 2. check format and whether the addressed subfunction is supported 3. aquire data or execute the required function call on the DEM, SW-Cs or other BSW modules 4. assemble the response\n\nThe DSP submodule will check for appropriate message length and structure before executing the requested command . the DSP triggers a negative response with NRC 0x13 when the analysis of the request message results in formatting or length failure.\nif the paged-buffer mechanism is used the DSP submodule shall determine the overall response length before any data is passed to the DSD submodule respectively. The DSP submodule shall confirm the completion of the request processing with the function call Dcm_ExternalProcessingDone()",
    "crumbs": [
      "{{< fa house >}} Home",
      "Autosar",
      "Diagnostic communication manager"
    ]
  },
  {
    "objectID": "Autosar/DCM.html#description",
    "href": "Autosar/DCM.html#description",
    "title": "Diagnostic communication manager",
    "section": "",
    "text": "Diagnostic session control module ensures diagnostic data flow and manages the diagnostic states, especially diagnostic sessions and security states .\nThe DCM module provides the OSI-layers 5 to 7\nOSI Layers and Diagnostic Protocols linking\n\n7- UDS 14229\n6-\n5- ISO 15765-3 - UDS on CAN\n4- ISO 15765-2\n3- ISO 15765-2\n2- CAN procotol, LIN Protocol, Flexray, MOST\n1- CAN procotol, LIN Protocol, Flexray, MOST \n\nThe dcm module receives diagnostic messages from the pdur module . once the dcm gets all the data it sends a message back throught he PduR module\nPdur (protocol data unit router) : The PduR module provides functions to trasmit and receive diagnositc data\nCommunication Manager(ComM): The ComM module provides functions such that the dcm can indicate the states “active” and “inactive” for diagnostic communication\nDCM handles the communication requirements such as Full/Silent/No-Communication. dcm module provides the functionality to enable and disable diagnositc communication if requested by the ComM module.\nDCM indicates to the BswM a communication mode change and notifies if the dcm is initailised due to jump from bootloader to application\n\n\n\nIf the diagnostic service is not sucesful due to any reason the corresponding NRC will be set and sent along with response to the diagnostic request\n\n\n\n\nDCM is devided in to 3 parts\n\n\nDSL-Diagnostic Session Layer\n\n\ncontrols diagnostic protocol timing and manages the security and sessions\n\n\nDiagnostic Service Dispatcher\n\n\nreceives new diagnositc request over a network and forwards it to a data processor\nTransmits a diagnositc response over a netowork when triggered by the data processor(DSP)\n\n\nDiagnostic Service Processing\n\n\nThe DSP submodule handles the actual diagnostic service requests . \n\n\n\n\n\n\n\nSessions handling as required by ISO 14229 and ISO 15765-3\nApplication layer timing handling as required by ISO 14229 and ISO 15765-3\nSpecific response behabiors as required by iso 14229 and iso 15765-3\n\n\n\n\nThe DSL has the following interaction wwith other modules : ##### PduR Module : - PduR module provides data of incoming diagnostic requests - The DSL submodule triggers output of diagnostic responses ##### DSD Submodule : - The DSL informs the dsd about incoming requests and provides the data - the DSD submodule triggers output of diagnostic responses ##### DSP submodule : - The DSL provides access to security and session state ##### ComM module : - The DSL guarantees the communication behavior required by the ComM module\n\n\n\n\n\n\nForwards request from the PduR module to DSD\nConcurrent test present (Keep alive logic - 3E service from ISO 14229) - if the 3E service requested with suppressPosRspMsgIndication bit set to be true (subfunction 0x80) ,DSL reset S3 server timing. also it shall not forward this request to DSD fof further interpretation\n\n\n\n\n\nForwards responses from the dsd to the PduR - via api PduR_DcmTransmit\nGuarantee response timing to tester if the service takes more time to respond then DSL shall send NRC 0x78 when reaching the response time P2 server max( DcmDspSessionP2ServerMax) from the next 0x78 waits for P2* server timeDcmDspSessionP2StarServerMax . DSL sends the negative responses as required from a separate buffer. The Max number of response pending(0x78) is configurable using DcmDslDiagRespMaxNumRespPend in order to avoid the deadlocks in the application. Once it reaches the Resp pending counter it shall send NRC (0x10) indicating general reject.\n\n\n\n\n\nManage security level\n\n\n\n\n\nManage session state :DSL get the current active session via Dcm_GetSesCtrlType() and set a new session through DslInternal_SetSesCtrlType() During dcm initialisation the default state is et which is Default session(0x01) when ever a non deault session is active and when the session timeout (S3 server)timing reaches without receiving any diag request , the DSL shall reset to the deault session by calling mode switch api of mode switch interface\nKeep track of active nond efault sessions\nAllow modifying timings DCM mdoule handle the following protocol timing parameter P2ServerMin,P2ServerMax,P2*ServerMin,P2*ServerMax,S3Server Generally these parameter set as\n\n\n\n\n\nHandling of Full/Silent/No Communication\nIndicating of active/inactive diagnostic\nEnabling/Disabling all kinds of diagnostic transmissions\n\n\n\n\n\n\nIt checks the validity of an incoming diagnostic request such as - Verification of diagnostic session - Security access levels - Application permission And keeps track of the progress of a service request execution\nThe DSD shall process only valid requests and shall reject invalid ones\n\n\n\nReceive a request message and transmit positive response message\n\nThe DSD ensures the validity of the request message.In this case if the request is valid the response will be positive .The request will be forwarded to the data process in the DSP. after DSP completes it triggers the transmission of response message by the DSD. If the response processing takes more time by the DSP may be waiting for read/write operation to eeprom then the response pending is covered by the DSL . When the request diag received the corresponding DcmPduId is blocked by the DSL .During the processing of this request , no other request of the same protocol type can be received, until the corresponding response message is sent and the DcmPduId if released again\n\nReceive a request message and supress the positive response\n\nIf the suppress positive response bit is set in the diag request in msb bit of sub function parameter .this kind of message completely handled by the DSD\n\nReceieve a request message and suppress the negative response\n\nIn case of functional addressing the DSD shall suppress the negative response for NRC 0x11 , 0x12 and 0x31\n\nReceive a request messahe and trasmit the negative response message\n\nDiag request is not valid or any condition not met to send the positive response the negative responses will be sent . In this case the DSP trigger a negative response with nrc indicating why the request was rejected . In case of 0x22 service if more than one did read operation is requested and if not all of the requested read did not failed only for the passed did the response will be sent .\n\nSend a positive response message without corresponding request\n\nThere are two services in the UDS protocol where multiole responses are sent for only one request . One service is used to enable(and disable)an event or time triggered transmission of another service , which is sent byt he ECU without a corresponding request. These services are \n\nRead Data by periodic identifier(0x2A)\nReponse on Event(0x86) These service handling is controlled by the DSL.However,DSD also provides the possibility to generate a response without a corresponding request.\n\n\nSegemented responses(Paged buffer):\n\nServices such as 0x19 and 0x36 exchange huge amount of data. So in this case the ecu internal buffer must be large enough to keep the longest data message which is to be exchnaged and the complete buffer is filled before the transmission is started . In a more RAM memory saving approach the buffer is filled only partly , transmitted partly and then refilled partly and so on. This paging mechanism rewuires only a reduced amount of memory but demands a well defined reaction time for buffer refilling . The user can decide whether to use the linear buffer or paged bugger for diagnostic\n\n#### DSD interaction with other modules\n\nDelegates the processing of request to the DSP\nKeeps track of request processing\nTransmit the response of the application to the DSL\n\n#### Functional description\n\nThe DSD shall be triggered by the DSL , if a new diagnostic message is recognised .\nThe DSD will sart processing by analyzing the diagnostic service indentifier contained in the received diagnositc message\nif the newly received the diagnositc request sid is not supported then the DSD shall transmit the negative response with NRC 0x11 to the DSL.\nVerification Functionality :The DSD accept service only if below 3 verifications are passed\n\nVerification of the Diagnostic session: On receiving the uds request dsd gets the current diagnostic session using api Dcm_GetSesCtrlType and verify whether the requested service and sub function are allowed in the current diagnostic session or not . (Note :0x10 service handling not part of DSD) If the received diag service is not allowed in the current diag session the DSD transmit the negative response with NRC 0x7F (service not supported in the active session)to the DSL submodule. If the received diag service is allowed in the current diag session but the sub function is not allowed in the current diag session then the DSD transmit the negative response with NRC 0x7E (sub function not supported in the active session)to the DSL submodule.\nVerification of the service security access levels:\n\nThe DSD checks the current security level with api Dcm_GetSecurityLevel() If the received diag service is not allowed in the current security level then the DSD shall transmit negative response with NRC 0x33 (Security access denied) to the DSL submodule\n\nIf the received diag service is n allowed in the current security level but the requested sub function is not allowed then the DSD shall transmit negative response with NRC 0x33 (Security access denied) to the DSL submodule DSD checks whether subfunction supported , if not supported NRC 0x12 will be sent . DSD checks minimum message length\nVerification of the application environment/Permission Before processing the diag request the application requested to check permission /environment eg: if ecu is in run state the diag service execution not allowed , vehicle speed is higher then the service is not allowed to execute(eg : service 11)\n\n\nThe DSD pass the diag request to DSP service interpretor\nThe execution of the DSP service interpreter can have the results\n\nPositive result or\nNegative result\n\nFollowing possible responses can be assembled\n\nPositive response : DSP indicate calling Dcm_ExternalProcessingDone().The parameter Dcm_MsgContextType contains the diagnostic (response)messgae . Then the DSD adds the response SIDand then response data stream (returned by the application)in the parameter Dcm_MsgContextType\nNegative response : The DSP triggers specific NRC to the DSD . The DSD handle all the supported NRC from the application and defined in the Dcm_NegativeResponseCodeType.\nSuppression of response in case of a negative result of the execution and active functional addressing the dsd submodule shall activate the suppression of the following negative responses:\n\n\nNRC 0x011 - service not supported\nNRC 0x12 - subfunction not supported\nNRC 0x31 - request out of range\n\n\nno Response :\nInitiate transmission\n\nthe DSD shall forward the diagnostic(response)message (positive or negative response) to the DSL.\nthe DSL shall forward the diagnostic(response)message (positive or negative response)further to the PduR module by executing a DSL transmit functionality.\nThe DSL will receive the confirmation by the PduR upon forwarding the dada\n\nthe DSL shall forward the received confirmation from the PduR to the dsd submodule.\nthe dsd shall forward the confirmation via the internal function DspInternal_DcmConfirmation() to the DSP submodule.\nIn case no diagnostic(response)message shall be sent(suppression of responses)the DSL submodule shall not transmit any response.\n\n\n\n\n\n\n\n\nWhen dsd request the dsp to process the diag request .it executed following basic process 1. analyze the received request message 2. check format and whether the addressed subfunction is supported 3. aquire data or execute the required function call on the DEM, SW-Cs or other BSW modules 4. assemble the response\n\nThe DSP submodule will check for appropriate message length and structure before executing the requested command . the DSP triggers a negative response with NRC 0x13 when the analysis of the request message results in formatting or length failure.\nif the paged-buffer mechanism is used the DSP submodule shall determine the overall response length before any data is passed to the DSD submodule respectively. The DSP submodule shall confirm the completion of the request processing with the function call Dcm_ExternalProcessingDone()",
    "crumbs": [
      "{{< fa house >}} Home",
      "Autosar",
      "Diagnostic communication manager"
    ]
  },
  {
    "objectID": "Autosar/DEM.html",
    "href": "Autosar/DEM.html",
    "title": "Diagnostic event manager",
    "section": "",
    "text": "The DEM module provides function to retrieve all information related to fault memory such that the DCM module is able to respond to tester requests by reading data from the fault memory\nPDUR :\nDCM is devided in to 3 parts\n\n\nDSL-Diagnostic Session Layer\nDiagnostic Service Dispatcher\nDiagnostic Service Processing",
    "crumbs": [
      "{{< fa house >}} Home",
      "Autosar",
      "Diagnostic event manager"
    ]
  },
  {
    "objectID": "Autosar/DEM.html#description",
    "href": "Autosar/DEM.html#description",
    "title": "Diagnostic event manager",
    "section": "",
    "text": "The DEM module provides function to retrieve all information related to fault memory such that the DCM module is able to respond to tester requests by reading data from the fault memory\nPDUR :\nDCM is devided in to 3 parts\n\n\nDSL-Diagnostic Session Layer\nDiagnostic Service Dispatcher\nDiagnostic Service Processing",
    "crumbs": [
      "{{< fa house >}} Home",
      "Autosar",
      "Diagnostic event manager"
    ]
  }
]